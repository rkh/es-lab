%
%  Proxies
%
%  Created by Tom Van Cutsem on 2010-01-18.
%  Copyright (c) 2010 Google. All rights reserved.
%
\documentclass{acm_proc_article-sp}

% Use utf-8 encoding for foreign characters
%\usepackage[utf8]{inputenc}

% Setup for fullpage use
%\usepackage{fullpage}

% Multipart figures
%\usepackage{subfigure}

\usepackage{multirow}
\usepackage{rotating}

% Package for including code in the document
\usepackage{listings}
\lstdefinelanguage{javascript}{
   morekeywords={break,do,instanceof,typeof,case,else,new,var,catch,finally,return, void, continue, for, switch, while, debugger, function, this, with, default, if, throw, delete, in, try, class, enum, extends, super, const, export, import, implements, let, private, public, interface, package,protected, static, yield},
   keywordstyle=\bfseries,
   ndkeywords={},
%                >>>=
%              , >>= , >>> , === , !==, <<=
%              , +=  , -=  , *=  , %= , >=
%              , ==  , !=  , ++  , -- , <<
%              , >>  , <=  , &=  , ,= , ^=
%              , &&  ,
%              , {     , }     , (     , )    , [   , ]
%              , .     , ;     , ,     , <    , >   , !
%              , ~     , =     , &     , ,    , ^   , ?
%              , :     , *     , %     , +    , -
   ndkeywordstyle=\bfseries,
   identifierstyle=\ttfamily,
   sensitive=false,
   comment=[l]{//},
   morecomment=[s]{/*}{*/}, 
   commentstyle=\itshape,
   stringstyle=\ttfamily
}

\lstset{
   language=JavaScript,
   %extendedchars=true,
   basicstyle=\scriptsize,
   showstringspaces=false,
   numbers=left,
   numberstyle=\tiny,
   stepnumber=5,
   numbersep=5pt,
   %frame=trbl, % for a rectangle
   frameround=tttt, % rounded rectangle
   frame=lines, % for only top and bottom lines
   float=ht,
}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

%\ifpdf
%\usepackage[pdftex]{graphicx}
%\else
\usepackage{graphicx}
%\fi

\newcommand{\noSuchMethod}{\texttt{\_\_noSuchMethod\_\_}}

\title{Proxies: Design Principles for Robust Object-oriented Intercession APIs}
% \subtitle[Extended Abstract]
% \titlenote{}

\numberofauthors{2}
\author{
\alignauthor
Tom Van Cutsem\titlenote{Tom Van Cutsem is a Postdoctoral Fellow of the Research Foundation, Flanders (FWO). This work was carried out while on a Visiting Faculty appointment at Google, sponsored by Google and a travel grant from the FWO.}\\
       \affaddr{Vrije Universiteit Brussel}\\
       \affaddr{Pleinlaan 2}\\
       \affaddr{1050 Brussels}\\
       \email{tvcutsem@vub.ac.be}
% 2nd. author
\alignauthor
Mark S. Miller\\%\titlenote{}\\
       \affaddr{Google}\\
       \affaddr{1600 Amphitheatre Parkway}\\
       \affaddr{Mountain View, CA, USA}\\
       \email{erights@google.com}
}

\date{}

\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle

\begin{abstract}
\end{abstract}

%\category{H.4}{Information Systems Applications}{Miscellaneous}
%\terms{Theory}
%\keywords{}

\section{Introduction}

We describe the design of a new metalevel API for Javascript that enables the creation of generic proxies for objects. Such proxies are useful for creating generic interposing abstractions between objects, which are in turn useful for enforcing access control (sandboxing), for implementing adaptors around older libraries to enable change in the face of legacy compatibility constraints, etc. Proxies can also be used to create ``virtualized'' objects: persistent objects, remote objects, lazy creation of objects, \ldots

%General context/motivation
%need for proxy metalevel APIs to enable objects (and by extension entire APIs) to be fully virtualized.
%Virtualization -> emulation
%benefits *generic* patterns for:
%- access control (sandboxing)
%- adaptors for migrating away from older libraries (legacy compatibility constraints)
%- adaptors for interfacing with another system (e.g. Javascript/Caja, AmbientTalk/Java or more generally: <your favourite scripting language>/JVM)
%- tracing/logging/profiling

We will use the term \emph{intercession API} to refer to any API, framework or language feature that enables the creation of new base-level objects with custom meta-level behavior.
% do our claims also hold true for non OO APIs?

The goals of this paper are:
\begin{itemize}
  \item To introduce in detail a robust proxy-based intercession API for Javascript.
  \item To share some design principles that we have applied successfully to our API, but which we think should be applicable to similar such APIs for other languages or systems.
\end{itemize}

\section{Background: Reflection}

Before we discuss Javascript's support (and lack of support) for reflection, we introduce some terminology from the field of computational reflection~\cite{maes-oopsla87} and metaprogramming~\cite{kiczales-artofthemop}.

\subsection{Metaobject Protocols}
\label{sub:metaobject_protocols}

A metaobject protocol is basically an object-oriented framework that describes the behavior of an object-oriented language.

A metaobject protocol supports \emph{introspection} if it enables reflective access to the structure of an object, and the values contained in this structure. It supports \emph{self-modification} if it is possible to modify this structure (e.g. add a new method, assign a field). It further supports \emph{invocation} if it enables the reflective invocation of an object's behavior. Finally, it supports \emph{intercession} if it enables the creation of meta-objects with custom structure and behavior.

The first three operations are typically well-supported by most metaobject protocols. Java's \texttt{java.lang.reflect} package, for example, supports introspection, invocation and limited self-modification. However, metaobject protocols that additionally support intercession are rare. The CLOS metaobject protocol is the foremost example of a metaobject protocol supporting intercession~\cite{clos}.

It is customary for a metaobject protocol to represent language operations defined on objects as methods of their meta-objects. Throughout the rest of this paper, we use the term ``operation'' to characterize operations such as message sending, property access, assignment, method definition, performing an \texttt{instanceof} operation, and so on.

In a pure object-oriented language, the dominant operation applied to objects is the message send (or method invocation). It is therefore unsurprising to observe that, historically, many object-oriented languages have provided ``ad hoc'' intercession of method invocations. For example, in Smalltalk, the class \texttt{Object} defines a method named \texttt{doesNotUnderstand:}. When the Smalltalk VM cannot find a method selector in an object's class or superclasses, it invokes the object's \texttt{doesNotUnderstand:} method instead, passing along a reified message object. While this approach is simple and flexible, we describe its drawbacks in section~\ref{sub:intercession_in_javascript}.

%Another well-known example of an ad-hoc intercession API is Java's \texttt{java.lang.reflect.Proxy} abstraction. Proxies are instances of classes that implement one or more interfaces. A proxy instance is created with a reference to an \texttt{InvocationHandler} instance and a list of interface types. The Java VM synthesizes a new class that implements these interfaces. All invocations on the proxy are reified as calls to the proxy's associated invocation handler's \texttt{invoke} method. The distinction between proxies and invocation handlers avoids the pitfalls of the \texttt{doesNotUnderstand:} approach, and our intercession API for Javascript is based on Java's proxy mechanism (cf. Section~\ref{sec:proxies_for_javascript}).

\subsection{Intercession: use cases}
\label{sub:use_cases}

Distinction based on whether the proxy is proxying another object within the same physical address space.

\begin{description}
  \item[Generic wrappers] access control, profiling, coverage, tracing, ...
  \item[Virtual objects] persistent objects, remote objects, transparent futures/promises, ...
\end{description}

\section{Javascript}

\section{A Brief History of Javascript}

Javascript is a scripting language whose language runtime is often embedded within a larger execution environment. By far the most common execution environment for Javascript is the web browser.

% Javascript vs ECMAScript
% ECMAScript 3, ECMAScript 5, es5-strict, ECMAScript Harmony
%  we should definitely introduce es5 seal,freeze,preventExtensions and property attributes
The official, standardized version of the Javascript language is named ECMAScript. The latest edition of ECMAScript, ECMA-262, 5th edition~\cite{ecma262}, adds to the language support for defensively consistent objects: objects that can protect themselves from unwanted modifications by untrusted client objects (such as inadvertent addition, overriding or removal of properties). ECMAScript 5 also defines a ``strict mode'' subset of the language. Strict mode addresses many of Javascript's perceived ``language warts'', edge cases and inconsistencies.

% Execution environment: the browser (DOM API for interacting with webpage, XHR object)
%In this environment, the global object is named \texttt{window} and gives Javascript objects access to the content and structure of web pages via the Document Object Model (DOM), and allows them to communicate with their originating server through XmlHttpRequests (XHR).

% The 'good parts': objects, arrays, functions
While the full Javascript language as we know it today is the product of a complex evolutionary process, at its core it is actually a simple dynamic language with first-class lexical closures and a surprisingly expressive object literal notation that enables the lightweight creation of one-off, anonymous, objects. This simple core is what Crockford refers to as ``the good parts''~\cite{crockford_goodparts}.

\subsection{Introspection and Invocation in Javascript}
\label{sub:introspection_in_js}

Javascript has built-in support for introspection, invocation and self-modification. In fact, these properties are provided as part of the language, rather than through a distinct metaobject protocol. This is largely because Javascript objects are represented as flexible records mapping arbitrary strings to values. In Javascript, a property name is just a string. Property names can be computed at runtime and their value can be retrieved using array indexing notation. The following code snippet demonstrates introspection, invocation and self-modification in Javascript:

\begin{lstlisting}[language=javascript]
var o = {
  x: 5,
  m: function(y) { return this.x + y; }
};
// introspection:
o["x"] // property access
"y" in o // property lookup
Object.keys(o) // array of own property names
// invocation:
o["m"].call(o,2) // method call
// self-modification:
o["x"] = 6 // property assignment
o.z = 7 // add a property
delete o.z // remove a property
\end{lstlisting}

One of the major changes of the latest standard, ECMAScript 5, is the addition of a new object-manipulation API that provides programmers with more fine-grained control over the nature of properties~\cite{ecma262}. Ecmascript 5 associates with each property in an object a set of attributes, describing whether the property is writable (i.e.~can be set), enumerable (~i.e. appears in \texttt{for-in} loops) or configurable (~i.e. whether these attributes themselves are mutable). The following code snippet shows how these attributes can be inspected and defined.

\begin{lstlisting}[language=javascript]
var pd = Object.getOwnPropertyDescriptor(o, 'x');
x.value // 5
x.writable // true

Object.defineProperty(o, 'z', {
  value: 7,
  writable: false,
  enumerable: false,
  configurable: true
});

var obj = Object.create(proto, {
  x: { value: 5, enumerable: true },
  y: { get: function(y) { return this.x + y; },
       enumerable: true }
});
\end{lstlisting}

The \texttt{pd} object and the third argument to \texttt{defineProperty} are called \emph{property descriptors}. They are objects that describe properties of objects.

The built-in \texttt{Object.create} function can be used to generate new objects based on a set of property descriptors. Its first argument specifies the prototype of the object to be created. Its second argument is an object serving as a record mapping property names to property descriptors. These descriptors then the attributes of the new object's properties.

For the first time in the history of Javascript, the availability of these new attributes enables the creation of objects that can prevent their clients from tampering with their properties. Ecmascript 5 introduces the notion of non-extensible, sealed and frozen objects. Non-extensible objects cannot be extended with new properties. Sealed objects are non-extensible and all of their properties are non-configurable. Frozen objects are sealed and all of their properties are non-writable. To freeze an object \texttt{obj}, one invokes \texttt{Object.freeze(obj)}. We describe in Section~\ref{} how the addition of these kinds of objects has influenced the design of our intercession API.

\subsection{Intercession in Javascript}
\label{sub:intercession_in_javascript}

Javascript has no built-in support for intercession. It is not possible to redefine the application of the dot-operator, array indexing, the \texttt{in}-operator and so on.

Spidermonkey, Mozilla's implementation of Javascript, has long included a non-standard way of interceding method calls based on Smalltalk's \texttt{doesNotUnderstand:} method. In Spidermonkey, this method is named \noSuchMethod{}. For example, a proxy that can generically forward all received messages to a target object \texttt{o} is created as follows:

\begin{lstlisting}[language=javascript]
function makeProxy(o) {
  return {
    __noSuchMethod__: function(prop, args) {
      return o[prop].apply(o,args);
    }
  };
}
\end{lstlisting}

% discuss the problems of __noSuchMethod__ (extension of Firefox to enable the creation of proxies in the tradition of Smalltalk-like 'doesNotUnderstand:' hooks)
In what follows, we will refer to methods such as \noSuchMethod{} and \texttt{doesNotUnderstand:} as \emph{traps}. The advantage of such traps is their perceived simplicity. The drawback is that the traps are not \emph{stratified}.

The only way in which a trap is distinguished from a regular method is by their name. Programmers that are unaware of the naming convention could accidentally define a method with the same name, leading to unexpected interactions. A violation of stratification can lead to two subtly different kinds of confusion:

\begin{itemize}
  \item Say an object \texttt{o} purposely overrides the trap. Clients of an object can accidentally invoke the trap method as if it were an application-level method. Since traps are plain methods, nothing prevents these traps from being invoked as if they were plain methods. This confuses meta-level code, since the call ``originated'' from the base-level.
  \item Say an object \texttt{o} accidentally overrides the trap, treating that method name as part of the application. The VM may then incidentally invoke the application method as if it were a trap. This confuses the base-level code, since the call ``originated'' from the meta-level.
\end{itemize}

Granted, for a method named \noSuchMethod{} this hypothetical confusion may seem far-fetched, although in Smalltalk \texttt{doesNotUnderstand:} is a pretty reasonable name for an application to use. But this critique misses the essential point, which is that the intercession API is polluting the name space of the application. This is not a scalable approach. What if we were to introduce additional such traps to intercept not only method invocation, but also property access, assignment, lookup, enumeration, etc.? The number of ``reserved method names'' would quickly grow out of hand. The reason that the lack of stratification has not really posed a significant problem \emph{in practice} is that Spidermonkey and Smalltalk define only one such special method.

So far in our discussion, we have limited the confusion caused by the lack of stratification to the fact that a trap is invoked by the wrong code. However, there are many other ways in which the trap method may conflict with other base-level code. For example, in Javascript a common idiom is to enumerate all properties of an object. Say we want to populate the content of a drop-down list in an HTML form with id \texttt{id} with all of the properties of an object \texttt{obj}:

\begin{lstlisting}[language=javascript]
function populate(id, obj) {
  var select = document.getElementById(id);
  for (var name in obj) {
    // skip inherited properties
    if (!obj.hasOwnProperty(name)) continue;
    var opt = document.createElement('option');
    opt.text = name;
    select.add(opt, null); // append opt
  }
}
\end{lstlisting}

If \texttt{obj} defines \noSuchMethod{} for the sake of intercepting method invocations, this method will show up in the enumeration of \texttt{obj}'s properties, probably leading to unexpected results.

Another drawback of defining the trap as part of the proxy is that it becomes impossible to recursively trap invocations of the trap \emph{itself}. Say \texttt{p} is a proxy. The invocation \lstinline{p.__noSuchMethod__('foo',[1])} itself cannot be intercepted. It is not transparently insert another proxy \texttt{p2} in between the caller and \texttt{p} such that \texttt{p2}'s \noSuchMethod{} trap is invoked as \lstinline{p2.__noSuchMethod__('__noSuchMethod__',['foo',[1]])}. We will show in Section~\ref{sub:doublelifting} that this recursive pattern of proxying proxies themselves has benefits when proxies can trap more than a single operation.

\section{Javascript Proxies}
\label{sec:proxies_for_javascript}

Our intercession API for Javascript supports intercession only for distinct proxy objects, controlled by a handler object. The methods of the handler object describe the behavior of the language operations when applied to the proxy object. We will call these methods \emph{traps}.

The distinction between a proxy and its handler object enforces stratification of the traps. Traps are no longer methods defined as part of the intercepted object, but are defined on handlers. Handlers can be treated as ``meta-objects'' and their API is effectively the ``metaobject protocol''.

Also, the distinction between proxy objects and regular objects ensures that non-proxy objects (which we expect makes up the vast majority of objects in a system) do not pay the overhead associated with intercession. We support this claim with empirical data in section~\ref{benchmarks}.

A proxy for an object is created as follows:

\begin{lstlisting}[language=javascript]
var proxy = Proxy.create(handler, proto);
\end{lstlisting}

Here, \texttt{handler} is an object that is supposed to implement a particular meta-level API and \texttt{proto} is an optional argument object representing the proxy's prototype.

\begin{table*}[t]
  \begin{center}
    \begin{small}
    \begin{tabular}{|l|p{0.35\textwidth}|p{0.4\textwidth}|}
    \hline
    \textbf{Operation} & \textbf{Triggered by} & \textbf{Reified as}\\
    \hline
    \multicolumn{3}{|l|}{\textbf{Fundamental traps}}\\
    \hline
    Descriptor access & Object.getOwnPropertyDescriptor(proxy,name) & handler.getOwnPropertyDescriptor(name)\\
    \hline
    Descriptor definition & Object.defineProperty(proxy,name,pd) & handler.defineProperty(name,pd)\\
    \hline
    Own key listing & Object.getOwnPropertyNames(proxy) & handler.getOwnPropertyNames()\\
    \hline
    Property deletion & delete proxy.name & handler.delete(name)\\
    \hline
    Key enumeration & for (name in proxy) \{...\} & handler.enumerate()\\
    \hline
    Object fixing & Object.\{freeze,seal,preventExtensions\}(proxy) & handler.fix()\\
    \hline
    \multicolumn{3}{|l|}{\textbf{Derived traps}}\\
    \hline
    Property lookup & name in proxy & handler.has(name)\\
    \hline
    Own Property lookup & (\{\}).hasOwnProperty.call(proxy,name) & handler.hasOwn(name)\\
    \hline
    Property access & receiver.name & handler.get(receiver, name)\\
    \hline
    Property assignment & receiver.name = val & handler.set(receiver, name, val)\\
    \hline
    Own key enumeration & Object.keys(proxy) & handler.enumerateOwn()\\
    \hline
    \end{tabular}
    \end{small}
  \end{center}
  \caption{Operations reified by the intercession API}
  \label{tab:operations}
\end{table*}

Table~\ref{tab:operations} lists those base-level operations applicable to objects that are reified by our API. The name \texttt{proxy} refers to a proxy instance, \texttt{handler} to that proxy's handler, \texttt{proto} to the prototype specified in \texttt{Proxy.create} and \texttt{receiver} to either a proxy or an object that delegates (directly or indirectly) to a proxy. The distinction between fundamental and derived traps is explained in Section~\ref{sub:fundamental_vs_derived_traps}.

The simplest useful handler is that of a generic forwarding proxy. For such a handler, each trap simply applies the intercepted operation to a target object \texttt{obj}. Most use cases of proxies can be thought of as variations on this default forwarding semantics, usually just augmenting some operations.

\begin{lstlisting}[language=javascript]
function makeForwardingHandler(obj) {
  return {
   has: function(name) { return name in obj; },
   get: function(rcvr,name) { return obj[name]; },
   set: function(rcvr,name,val) {
     obj[name] = val; return true;
   },
   delete: function(name) { return delete obj[name]; },
   keys: function() { return Object.keys(obj) },
   ...
  };
};
var proxy = Proxy.create(makeForwaringHandler(obj),
                         Object.getPrototypeOf(obj));
\end{lstlisting}

\subsection{Stratification}

The handler is a regular object. It may delegate to other objects and its delegation chain and is completely independent from that of the proxy it handles. A single handler may handle multiple proxies. The handler can be a proxy itself (we will illustrate a use case of this in Section~\ref{sub:doublelifting}).

Calling \lstinline{aProxy.get}, \lstinline{aProxy.fix} explicitly on a proxy will not trigger the proxy's corresponding traps. Instead, the call will be reified like any other. That is, \lstinline{aProxy.fix([])} invokes the handler's \lstinline{invoke(aProxy,'fix',[])} trap. Traps can only be invoked explicitly on a proxy's handler, not on the proxy itself. This enforces stratification (the meta-level traps should not interfere with base-level method names). Thus, proxies continue to work correctly if an application (by accident or by design) uses the names \texttt{get}, \texttt{set}, \texttt{has}, etc.

This brings us to our first design principle:

\textbf{Stratification:} traps can be stratified by defining them on an object that is distinct from the proxy being intercepted.

\subsection{Temporary Intercession}
\label{sub:immutability}

Recall from section~\ref{sub:introspection_in_js} that Ecmascript 5 introduces the notion of non-extensible, sealed and frozen objects. These objects provide useful guarantees that programmers can rely upon. When designing a proxy mechanism, care should be taken that proxies cannot break these guarantees. For example, if \texttt{o} is an object, then \texttt{Object.freeze(o)} freezes that object. If the programmer knows \texttt{o} is frozen, he can rely on the fact that \texttt{o.foo} will consistently return the same value. If \texttt{o} is a proxy, we do not want a proxy to violate this assumption.

To reconcile non-extensible, sealed and frozen objects with proxies, we introduce an additional trap named \texttt{fix}. A call to \texttt{Object.freeze(proxy)} will be interpreted as:

\begin{lstlisting}[language=javascript]
var props = handler.fix();
if (props === undefined) {
  throw new TypeError();
} else {
  become(proxy, Object.freeze(
    Object.create(proto, props)));
}
\end{lstlisting}

The \texttt{fix} trap is introduced to enable a proxy to interact with the \texttt{Object.preventExtensions}, \texttt{Object.seal} and \texttt{Object.freeze} primitives available in ECMAScript 5. A non-extensible, sealed or frozen object should somehow restrict the handler’s freedom in terms of what it can return from subsequent calls to \texttt{set}, \texttt{get}, etc. For example, if previous invocations of \texttt{handler.get(p,'foo')} returned a non-undefined value (for some \texttt{handler} of a proxy \texttt{p}), then future invocations of \texttt{handler.get(p,'foo')} should return the same value when \texttt{p} is frozen.

Proxies enforce these restrictions as follows: every time an external object tries to freeze, seal or make a proxy non-extensible, the \texttt{fix} trap is invoked on the proxy’s handler. At that point, the handler has two options:
\begin{enumerate}
  \item either to refuse the request (by making its \texttt{fix} trap return \texttt{undefined}). The corresponding call to one of the restraining primitives will throw an exception.
  \item or to honor the request, and committing to it by generating a description of an object. The implementation then generates a fresh object based on this description, and from that point on the proxy effectively becomes that object and the handler is bypassed entirely. Any reference to the handler by the implementation is at that point released, making it available for GC. The proxy is now said to be ``fixed''.
\end{enumerate}

The \texttt{become} operation used in the above code snippet is clearly pseudo-code: it cannot be implemented within Javascript itself, but it can be quite easily implemented by the VM. The \texttt{props} object returned by the \texttt{fix} trap is the same kind of object passed as the second argument to \texttt{Object.create}: a record that maps property names to property descriptors. The \texttt{fix} trap reuses this existing object-description format to specify the object that the proxy is about to become.

Because of the fixing-protocol, proxies can essentially be in two states. When a proxy is \emph{trapping}, it intercepts all operations and invokes the corresponding handler trap. Once the \texttt{fix} trap returns an object description, the proxy is \emph{fixed}. Once a proxy is fixed, it remains forever fixed.

When an object proxy is fixed, the prototype of the generated object is the \texttt{proto} object passed during proxy construction or \texttt{null} if none was provided. The prototype of a function proxy is always \texttt{Function.prototype}, and this remains unchanged when fixing the function proxy.

\textbf{Temporary Intercession:} if an operation imposes strong consistency requirements on a proxy object (such as becoming immutable), intercession should be disabled for some or all of the operations intercepted by proxies.
%and thus enable the language runtime to enforce the stronger invariants associated with immutability.

Fixing does not necessarily need to be an ``all or nothing'' process. However, in the particular case of Ecmascript, we found this to be the simplest solution.

%\texttt{Object.isExtensible(proxy)} always returns \texttt{true} if a proxy is trapping and \texttt{false} when it is fixed.

%Design of metalevel API:
%Start from the principle of stratification (cf. Mirrors and Java Proxies, distinction handler vs proxy)
%However, current stratified APIs funnel all meta-level requests through one trap (e.g. in Java: InvocationHandler#invoke)
%
%this distinguishes us from most prior work:
%- either the API is not stratified (e.g. ST's doesNotUnderstand: and the plethora of similar mechanisms in other languages)
%- or it is, but does not support intercession (e.g. Mirrors)
%- or the API is stratified, supports intercession, but has only a single trap (e.g. Java proxies)
%exceptions: AmbientTalk, CLOS's class metaobjects?
%
%When introducing multiple traps, some traps could be 'specializations' or 'generalizations' of other traps.
%Example: 'get' vs. 'invoke' : 'invoke' is a general trap that can be defined in terms of the more specific 'get' trap.
%This can be easily modelled using OOP: traps are methods, some methods are more general 'template methods' defined
%in terms of lower-level methods.
%
%The advantage is that the metaprogrammer need only implement the lower-level traps. The higher-level traps will automatically
%work as expected, working in terms of the lower-level traps.

\subsection{Handlers as Proxies}
\label{sub:doublelifting}
% explain double lifting trick
% handler as a proxy, include figure
% discipline that a proxy only interacts with its handler through method invocation
% implies that at the meta-level, everything is a message send
% -> only need to provide an 'invoke' trap
% hides the complexity of the meta-level API
% apply this to membranes

A common use case for proxy handlers is, for example, to perform an access control check before performing the operation on some wrapped object. Only if the check succeeds is the operation forwarded. Since there are 12 different operations that proxy handlers can intercept, a straightforward implementation would have to duplicate the pattern of access checking and forwarding the operation in each trap. It's difficult to abstract this pattern, because each operation has to be ``forwarded'' in a different way, as exemplified by the forwarding handler in Section~\ref{sec:proxies_for_javascript}. Ideally, if all operations could be uniformly funneled through a single trap, the handler would only have to perform the access check once, in the single trap.

We can achieve such funneling of all operations through a single trap by treating a proxy handler \emph{itself} as a proxy. In meta-programming terms, this corresponds to shifting to the meta-meta-level. To avoid the confusion that invariably follows from such shifting between meta-levels, let us introduce some terminology. The \emph{base-level proxy} is the proxy object with which other regular application objects directly interact. That proxy's handler is the \emph{base-level handler}. If the base-level handler is itself a proxy, it is \emph{also} a \emph{meta-level proxy}. The handler of a meta-level proxy is a \emph{meta-level handler}.

We carefully designed the intercession API such that proxies only interact with their associated handler by invoking their traps. Proxies never assign, enumerate or test for the presence of traps on their handler. Because of this invariant, if the base-level handler is \emph{only} used in its role as the handler for a base-level proxy, the meta-level handler only needs to implement the \texttt{get} trap. Because method invocation is the only operation performed on meta-level proxies, only this single trap is triggered on meta-level handlers.

% TODO: include picture
% a --> b means 'b is the handler of a'
% a ==> b means 'a forwards operations to b'
% base-level proxy --> base-level handler --> meta-level handler ==> forwarding handler ==> target
%                    = meta-level proxy
% p.x                blh.get(p,'x')          mlh.get(blh,'get').apply(blh,[p,'x'])
%                                                                    fh.get(p,'x')      target['x']

Another way to explain why this funneling works is as follows. At the base-level, there is an assortment of operations that are performed on Javascript objects as computation progresses (e.g. property lookup, access, assignment, enumeration, \ldots). At the meta-level (that is: in the intercession API), all of these operations are reified uniformly as method invocations on handlers. Therefore, at the meta-level, the only operation performed on meta-level objects (base-level handlers) is property access, and meta-meta-level objects (meta-level handlers) only need to handle this single operation in their protocol.

If one shifts an extra level upwards to funnel all operations through a single trap of a meta-level handler, one must also shift an extra level downwards if these operations must eventually be applied to a base-level object. This can be accomplished by having the meta-level handler forward the operations to a generic forwarding \emph{handler}. The forwarding handler essentially translates meta-level operations back into base-level operations on a target object.

We will show an example of this technique of funneling all methods in Section~\ref{sec:examples}.

Naturally, one can apply this trick of shifting meta-levels at the meta-meta-level recursively. The API allows an arbitrary number of such meta-level shifts. This brings up the question of infinite meta-regress. Such an infinite regress is avoided as long as a proxy handler is eventually implemented as a concrete Javascript object, rather than as yet another proxy.

% Design Principle: handlers can be proxies themselves
% Design Principle: express all meta-level computation (interaction with the handler)
% using a single primitive such that shifting two levels requires intercession of only one operation
To summarize, this section reveals two important design principles of proxy-based intercession APIs:

\textbf{Meta-level shifting:} a proxy-based intercession API supports shifting to a new meta-level by implementing a handler as a proxy.

\textbf{Meta-level funneling:} the interaction between a proxy and its handler determines the API of the meta-meta-level. If the proxy only invokes the handler's traps, then the meta-meta-level API collapses to a single trap through which all meta-level operations are funneled.

\textbf{Funneling trap:} the trap through which all meta-level operations can be funneled, either directly or using mechanisms such as meta-level funneling.

For Javascript proxies, \texttt{get} is the funneling trap.

\subsection{Selective Interception}
% tradeoff between what to intercess and what to fix upfront

A proxy-based intercession API introduces a tradeoff between what operations can be intercepted by proxy handlers on the one hand, versus what operations have a reliable outcome from the language runtime and the programmer's point of view. We already briefly touched upon this issue in Section~\ref{sub:immutability} when discussing how proxies interact with operations that make non-extensible, sealed or frozen. As we have discussed, the \texttt{fix} trap enables a proxy handler to dynamically decide whether or not to commit to a fixed representation.

% commit to identity upfront (possible because we don't intercess equality)
Some operations may be so critical that we don't want proxies to influence their outcome. One such operation is testing for equality. In Javascript, the expression \texttt{a === b} determines whether \texttt{a} and \texttt{b} refer to identical objects. The \texttt{===} operator comes with an entire list of guarantees that are implicitly taken for granted by programmers. For example, \texttt{===} is commutative, transitive, reflexive and deterministic (it always reports the same answer given the same arguments). Furthermore, testing \texttt{a} and \texttt{b} for equality should not grant \texttt{a} access to \texttt{b} or vice versa. For all these reasons, we decided not to enable proxy handlers to trap \texttt{===}. Proxies cannot influence the outcome of this operation.

As in the case of \texttt{===}, the fact that an operation should be deterministic is a requirement for many operations. To uphold determinism, the operation should not be delegated to a proxy handler. However, just because an operation should have a deterministic result does not mean that it cannot be reliably intercepted. When an operation requires a deterministic, stable result, this result can be provided once to the proxy when it is created. There are two concrete examples of this in our intercession API.

The first example is that proxies must commit to their prototype upfront. Recall from section~\ref{sec:proxies_for_javascript} that the second argument to \texttt{Proxy.create} denotes the proxy's prototype. This has two important effects: the first is that Ecmascript's built-in operation \texttt{Object.getPrototypeOf} remains deterministic, even when applied to a proxy. The second is that proxies cannot influence \texttt{instanceof} when they are used as the left-hand operand: to determine whether \texttt{proxy instanceof Foo} is true, the implementation need only look at the prototype of \texttt{proxy}, which using our API it can do without consulting the proxy.

The second example is that proxies have to decide upfront whether or not they will represent a function. In Javascript, functions are almost plain objects, but they differ in some important aspects. The details are beyond the scope of this paper, but for example the expression \texttt{typeof o} evaluates to \texttt{"object"} if \texttt{o} is ``just'' an object and to \texttt{"function"} if \texttt{o} is a function. Creating a function proxy is quite distinct from creating an object proxy:

\begin{lstlisting}[language=javascript]
var call = function() { ... };
var cons = function() { ... };
var f = Proxy.createFunction(handler, call, cons);
f(1,2,3); // calls call(1,2,3)
new f(1,2,3); // calls cons(1,2,3)
f.x // calls handler.get(f,'x')
\end{lstlisting}

The first argument to \texttt{Proxy.createFunction} is exactly the same kind of handler object used to define object proxies. The additional arguments \texttt{callTrap} and \texttt{constructTrap} are functions that respectively reify Javascript's function call and \texttt{new} operator. By requiring proxies to determine at creation time whether or not they will proxy for an object or a function, the language runtime is able to uphold important invariants that it would have to forfeit if it would have to consult the \texttt{handler}. For example, unlike \texttt{create}, \texttt{createFunction} does not accept a prototype argument. Functions always inherit from \texttt{Function.prototype}, and this API enforces that invariant.

Another aspect to take into account when deciding whether or not a certain operation can be intercepted by a proxy is the fact that it may lead to arbitrary code being run in places where the language runtime or the programmer did not expect this to. For example, without our intercession API, the expression \texttt{name in obj} does not trigger Javascript code. Since \texttt{in} is a primitive operation, the evaluation of this expression occurs entirely within the language runtime, without it ever having to run non-native code. Proxies may change these assumptions.

In our particular case, proxies enable non-native code to run while evaluating the \texttt{in} operator, the \texttt{delete} operator and \texttt{for-in} loops, yet they preserve the integrity of \texttt{===} and \texttt{typeof}. It's hard to make general claims about what operations should generally be interceptable and which should not. It is a design decision that depends on the particulars of the system at hand. The point that we want to make is that it's important to recognize that such a tradeoff exists. This brings us to the following design principle:

\textbf{Selective interception:} determine what properties of an object should be to committed to upfront. If these properties are required to be stable but may be configurable, turn them into parameters of the proxy constructor rather than retrieving them via a handler trap.

\subsection{Fundamental versus derived traps}
\label{sub:fundamental_vs_derived_traps}

The handler protocol of our intercession API provides 12 traps in total, each intercepting a different Javascript operation applied to a proxy. The exact nature of the handler protocol will of course vary greatly from language to language. However, there is one interesting observation about our protocol that we think may apply to other languages as well: some traps can be expressed in terms of the semantics of other traps (i.e. the semantics of the operation which they intercept is subsumed by the semantics of some other operation). We will refer to such traps as \emph{derived} traps, since their implementation may in fact be derived from other, more \emph{fundamental} traps.

\subsubsection{Efficiency: the case for derived traps}

It turns out that our intercession API is comprised of 7 fundamental traps and 5 derived traps. If we can get away with 7 traps, why define 12 of them? The reason is efficiency: implementing a derived trap directly may be more efficient than using its default implementation based on the corresponding fundamental trap. In our particular design, as a rule of thumb, we introduced derived traps only if their implementation could intercept the operation with less allocations than the corresponding implementation based on the fundamental trap.

As a concrete example, consider the expression \texttt{name in obj}. The \texttt{in} operator returns a boolean indicating whether \texttt{obj} defines or inherits a property named \texttt{name}. If \texttt{obj} is a proxy, this operation will trigger the handler's \texttt{has(name)} trap, which should return a boolean. \texttt{has} is a derived trap: its semantics can be directly derived from the fundamental trap \texttt{getPropertyDescriptor} which, given a property name, returns either a property descriptor for a property corresponding to that name if it exists, or returns \texttt{undefined} otherwise. Clearly, \texttt{has} could have just been defined as:

\begin{lstlisting}[language=javascript]
has: function(name) {
  return this.getPropertyDescriptor(name) !== undefined;
}
\end{lstlisting}

While this is a correct implementation of \texttt{has}, the downside is that \texttt{getPropertyDescriptor} needlessly allocates a property descriptor in the case that the named property exists. A custom implementation of \texttt{has} can often avoid this allocation.

While defining the intercession API, we found that there is another force at play that can prevent designers from introducing a derived trap, even if it were more efficient.

\subsubsection{Consistency: the case against derived traps}

One reason \emph{not} to introduce a derived trap, even in the face of improved efficiency, is that introducing the distinction may break language invariants that may surprise the language runtime and programmers.

Once the API provides a proxy handler with both a fundamental and a derived trap, there is no guarantee that a proxy handler will effectively make sure that the derived trap is indeed semantically equivalent to the canonical derived implementation. For example, if a proxy handler is given the option to override both the \texttt{has} and the \texttt{getPropertyDescriptor} traps, it is not enforced that these traps return mutually consistent results. That is, without proxies, the programmer can count on the following invariant:

\begin{lstlisting}[language=javascript]
(name in obj) ===
  (Object.getPropertyDescriptor(name) !== undefined)
\end{lstlisting}

If \texttt{obj} is a proxy, this invariant is no longer guaranteed! \texttt{has} could return true and \texttt{getPropertyDescriptor} could return false. We may characterize a proxy handler with such a behavior as ``ill-defined'' or ``buggy'', but the fact of the matter is that both the language runtime and programmers can no longer count on the invariant being upheld.

The requirement of mutual consistency between operations is an opposing force in the decision of whether or not to introduce a derived trap for a certain operation. Whether the benefits of efficiency outweigh the mutual consistency of operations is, again, based on the particulars of the system and there is no general answer.

One interesting case where mutual consistency outweighed efficiency gain was the decision not to introduce a derived trap to intercept method invocations. In Javascript, a method call expression \texttt{obj.m(1,2,3)} is evaluated by looking up the property \texttt{m} in \texttt{obj}, and then applying the resulting value as a function to the arguments. This semantics can even be expressed approximately in Javascript itself as \texttt{var f = obj.m; f.apply(obj, [1,2,3])}.

In a first design iteration, we defined a separate trap for method invocations: the expression \texttt{proxy.m(1,2,3)} calls \texttt{handler.invoke(obj,'m',[1,2,3])} where \texttt{handler} is \texttt{proxy}'s handler. The expression \texttt{proxy.m} calls \texttt{handler.get(proxy, 'm')}. Clearly, given the invariant sketched in the previous paragraph, \texttt{invoke} is a derived trap corresponding to the more fundamental \texttt{get} trap. Its canonical derived implementation would be:

\begin{lstlisting}[language=javascript]
invoke: function(rcvr, name, args) {
  return this.get(rcvr, name).apply(rcvr, args);
}
\end{lstlisting}

\texttt{invoke} is a useful derived trap because in some cases it can avoid the allocation of a function. Say a proxy wants to virtualize some non-object resource as an object. Say this resource has a property \texttt{foo} that should behave like a method. Part of the proxy handler's traps could be implemented as follows:

\begin{lstlisting}[language=javascript]
get: function(rcvr, name) {
  if (name === 'foo') {
    return function(a,b) {
      // handle proxy.foo(a,b)
    } 
  } else ...
},
invoke: function(rcvr, name, args) {
  if (name === 'foo') {
    // handle proxy.foo(args)
  } else ...
}
\end{lstlisting}

Here, the \texttt{invoke} trap saves the allocation of a function that \texttt{get} has to perform to curry over the arguments of the invocation. Eventually, we dropped the \texttt{invoke} trap because the invariant that it can break is so deeply rooted in the understanding of Javascript's method invocation semantics.

Note that, even if the programmer of a proxy handler has the best intentions to uphold the consistency between fundamental and derived traps (as in the example code above), upholding the consistency introduces a maintenance cost: if either of the two traps is later changed, or any of them gets overridden in a delegating object, the other trap should likewise be changed or overridden.

\textbf{Fundamental versus Derived Traps:} an intercession API faces a tradeoff between defining a minimal API consisting only of fundamental traps versus defining a more complex API that introduces derived traps. Derived traps may be more efficient, but may break invariants that hold between the operations corresponding to the fundamental and the derived trap.

\subsection{Meta-level encapsulation}
\label{sub:meta_level_encapsulation}

An intercession API can be said to encapsulate its meta-level if, given a reference to a proxy, one cannot gain direct access to the proxy's handler. For our proxy API, this is the case. This ensures that the handler remains encapsulated behind its proxy. This allows the handler to ensure that its traps can only ever be invoked though the manipulation of its corresponding proxy.

If access to a proxy's handler is required, it is fairly straightforward for the proxy creator to provide such access. For example, the proxy creator could define its own proxy factory:

\begin{lstlisting}[language=javascript]
function MyProxyFactory() {
  var proxies = new EphemeronTable();
  return {
    create: function(handler, proto) {
      var proxy = Proxy.create(handler, proto);
      proxies.put(proxy, handler);
      return proxy;
    },
    handlerOf: function(proxy) {
      return proxies.get(proxy);
    }
  };
}
\end{lstlisting}

If a proxy \texttt{p} was generated using such a proxy factory \texttt{pf}, objects are able to retrieve the proxy's handler by invoking \texttt{pf.handlerOf(p)}.

An \texttt{EphemeronTable} is a special kind of weak-key hashtable. It is based on Smalltalk's Ephemerons~\cite{et_paper} and is a new data type proposed for inclusion in ES-Harmony~\cite{et_proposal}.
Using ephemeron tables, it's fairly straightforward to link a proxy to its handler without actually having to manipulate the proxy.

\subsection{Uniform Intercession}
\label{sub:uniform_intercession}

An intercession API supports uniform intercession if it enables the creation of proxies for all possible types of values in the language. Javascript proxies do not support uniform intercession, since they are only able to proxy for objects (object proxies) or functions (function proxies). Primitive values cannot be proxied.

The advantage of having a uniform intercession API is that it does not restrict programmers to use only language values that can be proxied. Conversely, it enables meta-programmers to use their intercession API on more potential base-level objects.

Java proxies are also a non-uniform intercession API. Proxies can only be constructed for interface types, not class types. As a result, proxies cannot be used in any situation where code is typed using class types rather than interface types, severely limiting their applicability in general.

%TODO: discuss Proxy.isTrapping?
%could be another important design principle: whether or not to fully virtualize an API
%A method is defined on \texttt{Proxy} to distinguish trapping proxies from regular objects or fixed proxies:
%\texttt{Proxy.isTrapping(anObject)} returns \texttt{true} if and only if \texttt{anObject} is a proxy and is in trapping mode. This is the single, reliable way of testing whether an object is a trapping proxy or not. Note that a proxy cannot influence the outcome of this method. Once a proxy is fixed, it is in all ways simply a normal object, with no built-in way to detect that it had ever been a trapping proxy.

\section{Examples}
\label{sec:examples}

We now show how to apply our proxy API to a number of concrete programming examples.

\subsection{Revocable Object References}
\label{sub:revoker}

Say an object \texttt{A} wants to hand out a reference to \texttt{C} to another object \texttt{B}. \texttt{C} could provide access to a precious resource, and for that reason \texttt{A} may want to limit the lifetime of the reference it hands out to \texttt{B}. In other words, \texttt{A} wants to have the ability to revoke \texttt{B}'s access to \texttt{C}.

One can implement this pattern of access control by wrapping \texttt{C} in a forwarder that additionally supports a method to stop forwarding. Such a forwarder is also known as a \emph{caretaker}~\cite{robust_composition}. Without proxies, the programmer is forced to write a distinct caretaker for each kind of object that should be wrapped. Proxies enable the programmer to abstract from the details of the wrapped object's protocol and instead write a \emph{generic} caretaker\footnote{For brevity, we left out the case in which \texttt{target} is a function, requiring the caretaker to be a function proxy.}:

\begin{lstlisting}[language=javascript]
function makeRevocableRef(target) {
  var enabled = true;
  return Object.freeze({
    caretaker: Proxy.create({
      get: function(rcvr, name) {
        if (!enabled) {throw new Error("revoked");}
        return target[name];
      },
      has: function(name) {
        if (!enabled) {throw new Error("revoked");}
        return name in target;      
      },
      // ... and so on for all other traps
    }, Object.getPrototypeOf(target)),
    revoker: Object.freeze({
      revoke: function() { enabled = false; }
    })
  });
}
\end{lstlisting}

Given this abstraction, \texttt{A} can now wrap \texttt{C} in a revokable reference, pass the caretaker to \texttt{B}, and hold on to the revoker such that the reference can later be severed.

The caretaker is a proxy whose handler is very similar to the generic forwarder defined in Section~\ref{sec:proxies_for_javascript} except that it explicitly checks the \texttt{enabled} flag before forwarding. As noted in Section~\ref{sub:doublelifting}, this is a pattern that can itself be abstracted by shifting meta-levels once more. If the caretaker's handler is itself a proxy, the meta-level handler can funnel all meta-level operations through a single \texttt{get} trap:

\begin{lstlisting}[language=javascript]
function makeRevocableRef(target) {
  var enabled = true;
  var baseHandler = makeForwardingHandler(target);
  var metaHandler = Proxy.create({
    get: function(rcvr, name) {
      if (!enabled) {throw new Error("revoked");}
      return baseHandler[name];
    }
  });
  return Object.freeze({
    caretaker: Proxy.create(metaHandler, 
                 Object.getPrototypeOf(target)),
    revoker: Object.freeze({
      revoke: function() { enabled = false; }
    })
  });
}
\end{lstlisting}

% insert figure of an invocation through a revocable ref
% ref.foo()
%   metaHandler.get(metaHandler, 'foo')()
%     metametaHandler.get(metametaHandler, 'get')(metaHandler,'foo')()
%   baseHandler['get'](metaHandler, 'foo')()
% target['foo']()

A limitation of the above caretaker abstraction is that objects exchanged via the caretaker are themselves not recursively wrapped in a revocable reference. In particular, if \texttt{C} defines a method that returns \texttt{this}, \texttt{B} could circumvent the caretaker and get hold of a direct reference to \texttt{C} by invoking that method. The abstraction discussed in the following section addresses this issue.

\subsection{Membranes}
\label{sub:membranes}
% es-lab's compartments building on membranes

A membrane is an extension of a caretaker that transitively imposes revocability on all references exchanged via the membrane~\cite{robust_composition}. In the following implementation, we make use of meta-level funneling once more to centralize the access control in a single trap:

\begin{lstlisting}[language=javascript]
function makeMembrane(initTarget) {
  var enabled = true;
  function wrapFunction(f) {
    return function() { // variable-arg function
      if (!enabled) {throw new Error("revoked");}
      try {
        return wrap(f.apply(wrap(this),
                    toArray(arguments).map(wrap)));
      } catch (e) { throw wrap(e); } 
    }
  }
  function wrap(target) {
    if (Object.isPrimitive(target)) {
      //primitives provide irrevocable knowledge
      return target; //no need to wrap them
    } 
    var baseHandler = makeForwardingHandler(target);
    var metaHandler = Proxy.create({
      get: function(rcvr, name) {
        return wrapFunction(baseHandler[name]);
      }
    });
    
    if (typeof target === "function") {
      var wrappedF = wrapFunction(target);
      return Proxy.createFunction(
        metaHandler, wrappedF, wrappedF);
    } else {
      return Proxy.create(
        metaHandler,
        wrap(Object.getPrototypeOf(target)));
    }
  }
  return Object.freeze({
    wrapper: wrap(initTarget),
    gate: Object.freeze({
      revoke: function() { enabled = false; }
    })
  });
}
\end{lstlisting}

A membrane consists of one or more wrappers. Every such wrapper is created by a call to the \texttt{wrap} function. Note that all wrappers belonging to the same membrane share a single \texttt{enabled} variable. Assigning the variable to \texttt{false} revokes all of the membrane's wrappers simultaneously.

Recall that this example makes use of meta-level funneling. The \texttt{metaHandler} resides at the meta-meta-level. Therefore, it knows that it need only implement a \texttt{get} trap, and it knows that whatever it returns from the \texttt{get} trap will be treated as a meta-level trap (a function) that will immediately be invoked. To be able to wrap the arguments of these invocations, the \texttt{get} trap returns a wrapped version of the default forwarding trap as defined by \texttt{makeForwardingHandler}.

If the object to be wrapped is a function (or a method, because Javascript methods are just functions), a function proxy is returned whose call trap is a wrapped version of the function, as defined by \texttt{wrapFunction}. The variable-argument function\footnote{In Javascript, \texttt{arguments} is an object that contains all arguments passed to a function. It is used to write variable-argument functions, and it is customary to convert this object into a proper array first.} returned by \texttt{wrapFunction} performs the actual wrapping of values that cross the membrane: arguments to methods cross the membrane in one direction, returned values or thrown exceptions in the other direction.

One problem with the above membrane abstraction is that it fails to uphold object identity across both sides of the membrane. If an object \texttt{o} is passed through the same membrane twice, an object on the other side of the membrane will receive two distinct wrappers \texttt{w1} and \texttt{w2}, such that \texttt{w1 !== w2}, even though both wrap an identical object. Likewise, passing \texttt{w1} or \texttt{w2} back through the membrane does not unwrap them but rather wraps them again. These limitations can be addressed by having the membrane maintain a map from objects to their wrappers, such that only one canonical wrapper is created per object. Maintaining a map from wrappers to objects allows wrappers to be unwrapped when they cross the membrane in the other direction.

Unfortunately, implementing these maps in Javascript is impossible without introducing severe memory leaks. Ephemeron tables are a proposed language feature for the upcoming Ecmascript standard that address this issue~\cite{ephemeron_proposal}.

\subsection{Script Compartments}

Application of the membrane abstraction to the isolation of mutually distrustful code:

\begin{lstlisting}[language=javascript]
var compartment = makeMembrane(eval);
var eval1 = compartment.wrapper;
var gate = compartment.gate;
var badCode = //load potentially malicious code
var result = eval1(badCode);
//use result
gate.revoke();
//contents of compartment gone and collectible
\end{lstlisting}

A membrane around an SES \texttt{eval}\footnote{Ref to \texttt{es-lab} project for SES and Securable ES5.} creates a compartment in which one can run potentially malicious code, confident that the resulting potentially malicious objects can interact with the world outside this compartment only as permitted by the objects you provide them. Once the compartment is revoked, not only is all their connectivity severed, it is severed in ways the garbage collector can recognize. Given a good enough collector, these hostile objects cannot even continue to occupy your memory.

\section{Implementation}
Briefly discuss Andreas Gal's Tracemonkey implementation.

\subsection{Micro-benchmarks}
Support the claim that proxies enable intercession at (virtually) no cost to regular objects.

\section{Related Work}

\textbf{Partial Behavioral Reflection} (PBH)~\cite{tanter} is a framework that describes the spatiotemporal extent of reification. Reflex is an intercession API for Java, based on bytecode rewriting, that supports partial behavioral reflection. Reflex allows one to define meta-objects for a particular group of Java objects. Furthermore, it allows the programmer to delimit the spatiotemporal scope during which a particular meta-object reifies the operations performed on its associated base-level objects.

In a PBH system, a single meta-object can control multiple base-level objects. The spatial scope of meta-objects is controlled using \emph{entity selection} and \emph{operation selection}: entity selection enables a meta-object to control what objects it will control. For example, all instances of one or more classes, or only a particular instance of a certain class. Operation selection determines what particular operations of the affected objects will be reified (e.g. only message sending or field access). PBH even enables intra-operation selection, where reification will only occur if the operation satisfies further conditions (e.g. only reify calls to a method named \texttt{foo}). A PBH system additionally enables \emph{temporal selection}, which allows meta-programmers to explicitly control the temporal scope during which a meta-object is active.

Reflex differs from our proxy approach in that it enables the creation of meta-objects that will act upon arbitrary existing objects. Nevertheless, some aspects of our proxy API can be understood in terms of PBH. Proxies induce a static form of entity selection: operations on proxy objects are reified, operations on non-proxy objects are not. Proxies may support temporal selection. For example, Javascript proxies only reify while they are in a trapping state. Once fixed, the proxy no longer reifies operations. Finally, proxies enable a static form of operation selection: some operations on proxies (e.g. \texttt{typeof}) are never reified, whereas others such as property access are always reified.

Another way of looking at Reflex is that it is a meta-proxy system: using Reflex, a programmer can define many different particular intercession APIs, each with their own settings for entity, operation and temporal selection.

%\subsection{Intercepting Method Invocations}

%We already discussed in Section~\ref{sub:metaobject_protocols} that many object-oriented systems provide ad hoc support for intercepting messages sent to objects. There is a general category of languages that provide a trap that triggers on missing method definitions only, as exemplified by Smalltalk's \texttt{doesNotUnderstand:}, Spidermonkey's \noSuchMethod{}, Ruby's \texttt{methodMissing}, the E language's \texttt{match} clause, and so on. There are also languages that provide traps that trigger on every method invocation, whether a method is present or not. Examples of this category include Python's \texttt{\_\_getattribute\_\_} and Groovy's \texttt{invokeMethod}. What all of these systems have in common is that the intercession is not stratified. The trap is always defined in a namespace populated with application-level methods.

%In \textbf{Python}, class objects may define methods with special method names (starting with \texttt{__}) that are invoked when certain operations are performed on instances of the class. For example, \texttt{x.y} calls \texttt{type(x).__getattribute__(x, "y")}, where \texttt{type(x)} denotes the class of \texttt{x}. The difference between Python's hooks and proxies is that hooks are not defined on a separate handler object but rather on the class itself. Because hooks are not technically stratified into a separate object, a naming convention is used to avoid name clashes with application-level methods.

\subsection{Mirrors}

This paper was heavily influenced by the work on mirrors. Bracha and Ungar~\cite{bracha_04_mirrors_oopsla} discuss the design principles of mirror-based meta-level architectures. The principle of stratification can be directly attributed to the mirror-based design. The use of mirrors naturally leads to a stratification of base and meta-level. Traditional reflection APIs usually define access to the reflective interface of an object as part of that object's own interface. A prominent example is the \texttt{getClass()} method defined on \texttt{java.lang.Object}. The result is a strong coupling between the base-level object and its meta-level representation (in the case of Java the resulting \texttt{Class} object). As a point in case, consider the difficulty of defining a mirror on a remote object. In Java, the \texttt{getClass()} method, when applied to a remote object proxy would invariably break the abstraction, as \texttt{getClass()} would reveal the proxy's class.

A mirror is a meta-level object that defines a view on a base-level object. Mirrors are manufactured by distinct objects known as mirror factories. To acquire a mirror on an object \texttt{o}, one does not ask \texttt{o} for its mirror but rather asks a mirror factory for a mirror on \texttt{o}. The logic of what kind of mirror to associate with what kind of object is not tied to an object's representation.

Systems with a mirror-based architecture include Self~\cite{ungar87power}, the Java Debugger API~\cite{jdi} and Newspeak~\cite{newspeak}. Mirrors naturally support introspection, reflective invocation and self-modification. It was an open question whether mirror-based architectures could support intercession. AmbientTalk answered this question affirmatively: it introduced the concept of a \emph{mirage}~\cite{mirages_dls_07,spe_journal_08}. Mirages directly inspired our work on Javascript proxies. A mirage is very much like our proxy. Its behavior is controlled by a separate handler, which in AmbientTalk is also a mirror. The only difference between AmbientTalk and Javascript in this regard, is that Javascript has no built-in notion of mirrors or mirror factories.

%One can think of a proxy handler as defining a mirror on the proxy. Upholding the Mirrors principle of stratification, given only a reference to a proxy, it's impossible to acquire a reference to its handler. If such a relationship is required, it can be provided as follows:

%\begin{lstlisting}[language=javascript]
%function makeCustomProxyFactory() {
%  var customProxies = new EphemeronTable();
%  return {
%    create: function(handler, proto) {
%      var proxy = Proxy.create(handler, proto);
%      customProxies.put(proxy, handler);
%      return proxy;
%    },
%    handlerOf: function(proxy) {
%      return customProxies.get(proxy);
%    }
%  };
%} 
%\end{lstlisting}

%Given such an abstraction, an object with a reference to a proxy \texttt{p} created by such a factory \texttt{f} can reference the proxy's handler as \texttt{f.handlerOf(p)}. This design conforms to the stratification principle of a mirror-based architecture.

\subsection{CLOS}

The Common Lisp Object System (CLOS) is known for its extensibility through its metaobject protocol~\cite{kiczales_artmop}. Because CLOS is a function-oriented as opposed to a message-oriented object system, it is difficult to transpose the design principles described in this paper to CLOS. In CLOS, computation proceeds mainly through generic function invocation, as opposed to sending messages to objects. The dispatch mechanism of generic functions can be modified through the ``generic function invocation protocol''. Most common use cases do not require this, however: if one simply wants to wrap existing methods, CLOS offers a powerful method combination protocol that can be used to insert behavior before, after or around existing methods.

CLOS supports a stratified form of intercession. CLOS classes can be declared to have a custom metaclass. That metaclass can then specialize the various protocols in which the class metaobject takes part. For example, the ``instance structure protocol'' describes the structure of, and access to, the class's instance variables. The main difference between the proxy approach and the CLOS metaclass approach is that metaclasses introduces customization of behavior at the class-level, while proxies introduce customization of behavior at the object-level.

\subsection{OO Intercession APIs: a comparison}
\label{sub:survey}

In this section we summarize a variety of object-oriented intercession APIs. For each of these APIs, we discuss whether and how they adhere to the design principles put forth in this paper. We do not guarantee that the range of systems described here covers all possible approaches, but the systems described here, taken together, do constitute a very wide range of possible intercession APIs. Each of these APIs has its own peculiarities. We briefly discuss the surveyed mechanisms and then summarize which of our design principles they uphold in Table~\ref{tab:related_work}.

\textbf{Java} The Java 1.3 \texttt{java.lang.reflect.Proxy} API is a major precedent to our Javascript proxy API. Java's dynamic proxies can be used to emulate instances of interface types:

\begin{lstlisting}[language=java]
InvocationHandler h = new InvocationHandler() {
  public Object invoke(Method m, Object[] args) {...}
}
Foo proxy = (Foo) Proxy.newProxyInstance(
  aClassloader, new Class[] { Foo.class }, h);
\end{lstlisting}

Here, \texttt{proxy} implements the \texttt{Foo} interface. \texttt{h} is an object that implements a single \texttt{invoke} method. All method invocations on \texttt{proxy} are reified by calling the \texttt{h.invoke} method, passing along a description of the invoked method and the arguments of the call.

The main difference between Java proxies and Javascript proxies is that Java proxies can only intercept method invocation. There are no other meta-level operations to trap. For instance, since interfaces cannot declare fields, proxies do not need to intercept field access.
%Implementation-wise, another important difference is that Java proxies can be supported by a JVM without the need for a special ``proxy'' object type. A description of the proxy (and all of its methods) can be generated from the given interfaces and subsequently instantiated as a normal object (whose class just happens to be synthesized at runtime).

%Mirages in AmbientTalk: adds intercession to a Mirror API
\textbf{AmbientTalk} The design of Javascript proxies was influenced by AmbientTalk \emph{mirages}~\cite{mirages_dls_07,spe_journal_08}. AmbientTalk is a distributed dynamic language, with a mirror-based meta-level API. AmbientTalk enables intercession through mirages, which are proxy-like objects controlled explicitly by a separate mirror object:

\begin{lstlisting}[]
def mirage := object: { ... } mirroredBy: (mirror: {
  def invoke(receiver, message) { ... };
  def addSlot(slot) { ... };
  def removeSlot(slot) { ... };
  ...
});
\end{lstlisting}

The mirror is to the mirage what the proxy handler is to a Javascript proxy. Like Javascript proxy handlers, mirrors define an extensive set of traps, enabling near-complete control over the mirage.

\textbf{E} E is a secure, distributed dynamic language~\cite{miller05strangers}. In E, everything is an object, but there are two kinds of object references: \emph{near} and \emph{eventual} references. Similarly, there are two message passing operators: immediate call (\texttt{o.m()}, a synchronous method invocation) and eventual send (\texttt{o<-m()}, an asynchronous message send). Both operations are allowed on near references, but eventual references carry only asynchronous messages. Because of this distinction, E has two separate intercession APIs: one for objects and one for references.

E has a proxy-based API to represent user-defined eventual references~\cite{e_wiki}:
%http://wiki.erights.org/wiki/Proxy
\begin{lstlisting}[]
def handler {
  to handleSend(verb :String, args :List) {...}
  to handleSendOnly(verb :String, args :List) {...}
  to handleOptSealedDispatch(brand) {...}
}
def proxy := makeProxy(handler, slot, state);
\end{lstlisting}

This API is very similar to the one of Javascript proxies. The proxy represents an eventual reference, and any asynchronous send \texttt{proxy<-m()} either triggers the handler's \texttt{handleSend} or \texttt{handleSendOnly} trap, depending on whether the sender expects a return value.

The \texttt{handleOptSealedDispatch} trap is part of E's trademarking system and is beyond the scope of this paper. The \texttt{slot} argument to \texttt{makeProxy} can be used to turn the proxy reference into an actual, so-called \emph{resolved} reference. Once a reference is resolved, the proxy is bypassed and the handler no longer consulted. It fulfills a role similar to the \texttt{fix} trap highlighted in Section~\ref{sub:immutability}.

E has a distinct intercession API for objects. A \emph{non-methodical object} is an empty object with no methods. Instead, its implementation consists of a single \texttt{match} clause that encodes an explicit message dispatch:

\begin{lstlisting}
def obj match [verb, args] {
  # handle the message generically
}
\end{lstlisting}

The variable \texttt{obj} is bound to a new object whose dispatch logic is explicitly encoded in the \texttt{match} clause. An immediate call \texttt{obj.m(x)} will trigger this clause, binding \texttt{verb} to \texttt{"m"} and \texttt{args} to a list \texttt{[x]}.

Finally, it is worth noting that AmbientTalk inherits from E the distinction between near and eventual references and the distinction between immediate call and eventual send. Unlike E, AmbientTalk has only one intercession API (mirages), but a mirage can represent \emph{both} objects and eventual references, depending on how the handler implements its traps.

\textbf{Smalltalk} Smalltalk-80 popularized generic message dispatch via its \texttt{doesNotUnderstand:} mechanism. Briefly, if standard method lookup does not find a method corresponding to a message, the Smalltalk VM instead sends the message \texttt{doesNotUnderstand: msg} to the original receiver object. Here, \texttt{msg} is an object containing the message's selector and arguments. The default behavior of this method, inherited from \texttt{Object} is to throw an exception.

The \texttt{doesNotUnderstand:} trap is not stratified. It occupies the same namespace as plain application-level methods. This lack of stratification did lead Smalltalk programmers to look for alternative interception mechanisms. Foote and Johnson describe a particular extension to ParcPlace Smalltalk called a \emph{dispatching class}: ``Whenever an object belonging to a class designated as a dispatching class (using a bit in the class object's header) is sent a message, that object is instead sent \texttt{dispatchMessage: aMessage}.''~\cite{foote_st80}. Instances of dispatching classes are effectively proxies, the \texttt{dispatchMessage:} method acting as the sole trap of an implicit handler.

Ducasse~\cite{ducasse99joop} gives an overview of the various message passing control techniques in Smalltalk. He concludes that \texttt{doesNotUnderstand:} is not always the most appropriate mechanism. Rather, he stresses the usefulness of \emph{method wrappers}. This approach was later elaborated by Brant \emph{et. al}~\cite{brant}. In this approach, rather than changing the \emph{method lookup}, the \emph{method objects} returned by the lookup algorithm are modified. This is possible because Smalltalk methods and method dictionaries are accessible from within the language. The method wrapper approach is in many ways similar to CLOS method combinations, enabling before/after/around augmentation of existing methods. As their name suggests, they are great for wrapping existing methods, but they seem less suitable to implement virtual objects and thus only support part of the use cases covered by \texttt{doesNotUnderstand:}.

\textbf{Summary} Table~\ref{tab:related_work} shows that each of the aforementioned intercession APIs has its own set of characteristics. It is difficult to declare one API to be better than another one. By their very nature, meta-level APIs are strongly tied to their particular language. The tradeoffs made by these APIs cannot be understood without reference to the idiosyncratic constraints and motivations of their respective languages. However, the one principle that we believe should be present in all robust OO intercession APIs is stratification.

\begin{table*}
\centering
\begin{tabular}{|p{0.20\textwidth}|p{0.80\textwidth}|}
    \hline
    \multicolumn{2}{|l|}{\textbf{What type of value is virtualized?}}\\
    \hline
    JS proxies        & Objects\\
    Java proxies      & Objects\\
    AT mirages        & Objects and eventual references\\
    E proxies         & Eventual references\\
    E non-methodicals & Objects\\
    ST \texttt{doesNotUnderstand:}  & Objects\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Is the API stratified?}}\\
    \hline
    JS proxies        & Yes, proxy versus handler\\
    Java proxies      & Yes, Proxy versus InvocationHandler\\
    AT mirages        & Yes, mirage versus mirror\\
    E proxies         & Yes, proxy versus ProxyHandler\\
    E non-methodicals & Yes, non-methodicals have no behavior other than their \texttt{match} clause\\
    ST \texttt{doesNotUnderstand:}  & No, proxy and handler are the same object\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Is the handler encapsulated?}}\\
    \hline
    JS proxies        & Yes\\
    Java proxies      & No, because of \texttt{Proxy.getInvocationHandler(proxy)}\\
    AT mirages        & Yes, but can get access indirectly via a mirror factory\\
    E proxies         & Yes\\
    E non-methodicals & Yes\\
    ST \texttt{doesNotUnderstand:}  & No, proxy and handler are the same object\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Can intercession be limited in time (temporary intercession)?}}\\
    \hline
    JS proxies        & Yes, by fixing the proxy (see Section~\ref{sub:immutability})\\
    Java proxies      & No, proxies remain proxies forever\\
    AT mirages        & No, mirages remain mirages forever\\
    E proxies         & Yes, by \emph{resolving} the proxied reference into a real reference\\
    E non-methodicals & No, non-methodicals remain non-methodicals forever\\
    ST \texttt{doesNotUnderstand:}  & Yes, by replacing the object using Smalltalk's \texttt{become:} primitive\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Can one shift meta-levels?}}\\
    \hline
    JS proxies        & Yes, if handler is itself a proxy\\
    Java proxies      & Yes, if handler is itself a proxy\\
    AT mirages        & Yes, if mirror is itself a mirage\\
    E proxies         & No, handler cannot itself be an eventual reference proxy\\
    E non-methodicals & No, non-methodicals have no handler\\
    ST \texttt{doesNotUnderstand:}  & No, cannot trap invocations of \texttt{doesNotUnderstand:} itself\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Is there a funneling trap?}}\\
    \hline
    JS proxies        & Yes, the \texttt{get} trap, for a meta-handler\\
    Java proxies      & Yes, the \texttt{invoke} trap, for any handler\\
    AT mirages        & Yes, the \texttt{invoke} trap, for a meta-handler\\
    E proxies         & Yes, if handler is a non-methodical object, its \texttt{match} clause is a funneling trap\\
    E non-methodicals & Yes, the \texttt{match} clause\\
    ST \texttt{doesNotUnderstand:}  & Yes, \texttt{doesNotUnderstand:} itself, if class is otherwise empty (no implemented or inherited methods). In this case, the class may not eventually inherit from \texttt{Object}\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Can all types of values in the language be virtualized (uniform intercession)?}}\\
    \hline
    JS proxies        & No, primitives cannot\\
    Java proxies      & No, instances of a non-interface class and primitives cannot\\
    AT mirages        & Yes, everything is an object or a reference (mirages cover both)\\
    E proxies         & Yes, everything is an object or a reference (proxies cover references)\\
    E non-methodicals & Yes, everything is an object or a reference (non-methodicals cover objects)\\
    ST \texttt{doesNotUnderstand:}  & Yes, everything is an object\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Are there some operations applicable on proxies that cannot be intercepted (selective interception)?}}\\
    \hline
    JS proxies        & Yes, identity, prototype and \texttt{typeof} are fixed\\
    Java proxies      & Yes, identity, class, and the \texttt{wait} and \texttt{notify} methods inherited from \texttt{Object}\\
    AT mirages        & Yes, an object's mirror is determined by a separate mirror factory object\\
    E proxies         & Yes, identity is fixed and the ``state'' of a reference is enforced\\
    E non-methodicals & Yes, identity and ``trademarks'' (unforgeable types) are fixed\\
    ST \texttt{doesNotUnderstand:}  & Yes, calls to methods implemented in or inherited by the defining class will not be intercepted\\
    \hline
    \multicolumn{2}{|l|}{\textbf{Is there a distinction between fundamental and derived traps?}}\\
    \hline
    JS proxies        & Yes, see Table~\ref{tab:operations}\\
    Java proxies      & No, \texttt{invoke} is the only trap\\
    AT mirages        & No, all traps are fundamental\\
    E proxies         & Yes, \texttt{sendOnly} can be derived from \texttt{send}\\
    E non-methodicals & No, the \texttt{match} clause is the only trap\\
    ST \texttt{doesNotUnderstand:}  & No, the \texttt{doesNotUnderstand:} method is the only trap\\
    \hline
  \end{tabular}
  \caption{Comparison of object-oriented intercession APIs}
  \label{tab:related_work}
\end{table*}

\section{Conclusion}

Recapitulate our ``design principles''. Should be generally applicable (apart from Javascript).
\begin{itemize}
  \item Stratification of proxy and handler.
  \item Selective interception: committing to values upfront.
  \item Fundamental versus derived traps: less allocation vs consistency.
  \item Meta-level shifting and funneling traps
  \item Fixing: dealing with immutability.
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{}
\end{document}

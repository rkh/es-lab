%
%  Proxies
%
%  Created by Tom Van Cutsem on 2010-01-18.
%  Copyright (c) 2010 Google. All rights reserved.
%
\documentclass{acm_proc_article-sp}

% Use utf-8 encoding for foreign characters
%\usepackage[utf8]{inputenc}

% Setup for fullpage use
%\usepackage{fullpage}

% Multipart figures
%\usepackage{subfigure}

\usepackage{multirow}

% Package for including code in the document
\usepackage{listings}
\lstdefinelanguage{javascript}{
   morekeywords={break,do,instanceof,typeof,case,else,new,var,catch,finally,return, void, continue, for, switch, while, debugger, function, this, with, default, if, throw, delete, in, try, class, enum, extends, super, const, export, import, implements, let, private, public, interface, package,protected, static, yield},
   keywordstyle=\bfseries,
   ndkeywords={},
%                >>>=
%              , >>= , >>> , === , !==, <<=
%              , +=  , -=  , *=  , %= , >=
%              , ==  , !=  , ++  , -- , <<
%              , >>  , <=  , &=  , ,= , ^=
%              , &&  ,
%              , {     , }     , (     , )    , [   , ]
%              , .     , ;     , ,     , <    , >   , !
%              , ~     , =     , &     , ,    , ^   , ?
%              , :     , *     , %     , +    , -
   ndkeywordstyle=\bfseries,
   identifierstyle=\ttfamily,
   sensitive=false,
   comment=[l]{//},
   morecomment=[s]{/*}{*/}, 
   commentstyle=\itshape,
   stringstyle=\ttfamily
}

\lstset{
   language=JavaScript,
   %extendedchars=true,
   basicstyle=\scriptsize,
   showstringspaces=false,
   numbers=left,
   numberstyle=\tiny,
   stepnumber=5,
   numbersep=5pt,
   %frame=trbl, % for a rectangle
   frameround=tttt, % rounded rectangle
   frame=lines, % for only top and bottom lines
   float=ht,
}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

%\ifpdf
%\usepackage[pdftex]{graphicx}
%\else
\usepackage{graphicx}
%\fi

\newcommand{\noSuchMethod}{\texttt{\_\_noSuchMethod\_\_}}

\title{Design Principles for Robust Intercession APIs}
% \subtitle[Extended Abstract]
% \titlenote{}

\numberofauthors{2}
\author{
\alignauthor
Tom Van Cutsem\titlenote{Tom Van Cutsem is a Postdoctoral Fellow of the Research Foundation, Flanders (FWO). This work was carried out while he was a Visiting Faculty at Google, sponsored by Google and a travel grant from the FWO.}\\
       \affaddr{Vrije Universiteit Brussel}\\
       \affaddr{Pleinlaan 2}\\
       \affaddr{1050 Brussels}\\
       \email{tvcutsem@vub.ac.be}
% 2nd. author
\alignauthor
Mark S. Miller\\%\titlenote{}\\
       \affaddr{Google}\\
       \affaddr{1600 Amphitheatre Parkway}\\
       \affaddr{Mountain View, CA, USA}\\
       \email{erights@google.com}
}

\date{}

\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle

\begin{abstract}
\end{abstract}

%\category{H.4}{Information Systems Applications}{Miscellaneous}
%\terms{Theory}
%\keywords{}

\section{Introduction}

We describe the design of a new metalevel API for Javascript that enables the creation of generic proxies for objects. Such proxies are useful for creating generic interposing abstractions between objects, which are in turn useful for enforcing access control (sandboxing), for implementing adaptors around older libraries to enable change in the face of legacy compatibility constraints, etc. Proxies can also be used to create ``virtualized'' objects: persistent objects, remote objects, lazy creation of objects, \ldots

%General context/motivation
%need for proxy metalevel APIs to enable objects (and by extension entire APIs) to be fully virtualized.
%Virtualization -> emulation
%benefits *generic* patterns for:
%- access control (sandboxing)
%- adaptors for migrating away from older libraries (legacy compatibility constraints)
%- adaptors for interfacing with another system (e.g. Javascript/Caja, AmbientTalk/Java or more generally: <your favourite scripting language>/JVM)
%- tracing/logging/profiling

We will use the term \emph{intercession API} to refer to any API, framework or language feature that enables the creation of new base-level objects with custom meta-level behavior.
% do our claims also hold true for non OO APIs?

The goals of this paper are:
\begin{itemize}
  \item To introduce in detail a robust proxy-based intercession API for Javascript.
  \item To share some design principles that we have applied successfully to our API, but which we think should be applicable to similar such APIs for other languages or systems.
\end{itemize}

\section{A Brief History of Javascript}

% Javascript vs ECMAScript
% ECMAScript 3, ECMAScript 5, es5-strict, ECMAScript Harmony
%  we should definitely introduce es5 seal,freeze,preventExtensions and property attributes
The official, standardized version of the Javascript language is named ECMAScript. The latest edition of ECMAScript, ECMA-262, 5th edition~\cite{ecma262}, adds to the language support for defensively consistent objects: objects that can protect themselves from unwanted modifications by untrusted client objects (such as inadvertent addition, overriding or removal of properties). ECMAScript 5 also defines a ``strict mode'' subset of the language. Strict mode addresses many of Javascript's perceived ``language warts'', edge cases and inconsistencies.

% Execution environment: the browser (DOM API for interacting with webpage, XHR object)
Javascript is conceived as a scripting language which implies that the language runtime is often embedded within a larger execution environment. By far the most common execution environment for Javascript is the web browser. In this environment, the global object is named \texttt{window} and gives Javascript objects access to the content and structure of web pages via the ``Document Object Model'' (DOM) API. Other important objects include the \texttt{XmlHttpRequest} (XHR) object that allows Javascript code to asynchronously communicate with its originating server.

% The 'good parts': objects, arrays, functions
At its core, Javascript is a simple dynamic language that inherits first-class lexically scoped functions from Scheme~\cite{scheme} and prototype-based objects from Self~\cite{self}. Javascript has a surprisingly expressive object literal notation that enables the lightweight creation of one-off, anonymous, objects.

\section{Reflection in Javascript}

Before we discuss Javascript's support (and lack of support) for reflection, we introduce some terminology from the field of computational reflection~\cite{maes-oopsla87} and metaprogramming~\cite{kiczales-artofthemop}.

\subsection{Metaobject Protocols}
\label{sub:metaobject_protocols}

A metaobject protocol is basically an object-oriented framework that describes the behavior of an object-oriented language.

A metaobject protocol supports \emph{introspection} if it enables reflective access to the structure of an object, and the values contained in this structure. It supports \emph{self-modification} if it is possible to modify this structure (e.g. add a new method, assign a field). It further supports \emph{invocation} if it enables the reflective invocation of an object's behavior. Finally, it supports \emph{intercession} if it enables the creation of meta-objects with custom structure and behavior.

The first three operations are typically well-supported by most metaobject protocols. Java's \texttt{java.lang.reflect} package, for example, supports introspection, invocation and limited self-modification. However, metaobject protocols that additionally support intercession are rare. The CLOS metaobject protocol is the foremost example of a metaobject protocol supporting intercession~\cite{clos}.

It is customary for a metaobject protocol to represent language operations defined on objects as methods of their meta-objects. Throughout the rest of this paper, we use the term ``operation'' to characterize operations such as message sending, property access, assignment, method definition, performing an \texttt{instanceof} operation, and so on.

In a proper object-oriented language, the dominant operation applied to objects is the message send (or method invocation). It is therefore unsurprising to observe that, historically, many programming languages have provided ``ad hoc'' intercession of method invocations. For example, in Smalltalk, the class \texttt{Object} defines a method named \texttt{doesNotUnderstand:}. When the Smalltalk VM cannot find a method selector in an object's class or superclasses, it invokes the object's \texttt{doesNotUnderstand:} method instead, passing along the selector and the arguments, reified as an array. Objects are free to treat the invocation however they please. The default response is to raise an exception stating that the message was not understood. While this approach is simple and flexible, we describe the drawbacks of this approach in section~\ref{sub:intercession_in_javascript}.

Another well-known example of an ad-hoc intercession API is Java's \texttt{java.lang.reflect.Proxy} abstraction. Proxies are instances of classes that implement one or more interfaces. A proxy instance is created with a reference to an \texttt{InvocationHandler} instance and a list of interface types. The Java VM synthesizes a new class that implements these interfaces. All invocations on the proxy are reified as calls to the proxy's associated invocation handler's \texttt{invoke} method. The distinction between proxies and invocation handlers avoids the pitfalls of the \texttt{doesNotUnderstand:} approach, and our intercession API for Javascript is based on Java's proxy mechanism (cf. Section~\ref{sec:proxies_for_javascript}).

\subsection{Introspection and Invocation in Javascript}
\label{sub:introspection_in_js}

Javascript has built-in support for introspection, invocation and self-modification. In fact, these properties are provided as part of the language, rather than through a distinct metaobject protocol. This is largely because Javascript objects are represented as flexible records mapping arbitrary strings to values. In Javascript, a property name is just a string. Property names can be computed at runtime and their value can be retrieved using array indexing notation. The following code snippet demonstrates introspection, invocation and self-modification in Javascript:

\begin{lstlisting}[language=javascript]
var o = {
  x: 5,
  m: function(y) { return this.x + y; }
};
// introspection:
o["x"] // property access
"y" in o // property lookup
Object.keys(o) // array of own property names
// invocation:
o["m"].call(o,2) // method call
// self-modification:
o["x"] = 6 // property assignment
o.z = 7 // add a property
delete o.z // remove a property
\end{lstlisting}

One of the major changes of the latest standard, ECMAScript 5, is the addition of a new object-manipulation API that provides programmers with more fine-grained control over the nature of properties~\cite{ecma262}. Ecmascript 5 associates with each property in an object a set of attributes, describing whether the property is writable (i.e.~can be set), enumerable (~i.e. appears in \texttt{for-in} loops) or configurable (~i.e. whether these attributes themselves are mutable). The following code snippet shows how these attributes can be inspected and defined.

\begin{lstlisting}[language=javascript]
var pd = Object.getOwnPropertyDescriptor(o, 'x');
x.value // 5
x.writable // true

Object.defineProperty(o, 'z', {
  value: 7,
  writable: false,
  enumerable: false,
  configurable: true
});
\end{lstlisting}

The \texttt{pd} object and the third argument to \texttt{defineProperty} are called \emph{property descriptors}. They are objects that describe properties of objects.

For the first time in the history of Javascript, the availability of these new attributes enables the creation of objects that can prevent their clients from tampering with their properties. Ecmascript 5 introduces the notion of non-extensible, sealed and frozen objects. Non-extensible objects cannot be extended with new properties. Sealed objects are non-extensible and all of their properties are non-configurable. Frozen objects are sealed and all of their properties are non-writable. To freeze an object \texttt{obj}, one invokes \texttt{Object.freeze(obj)}. We describe in Section~\ref{} how the addition of these kinds of objects has influenced the design of our intercession API.

\subsection{Intercession in Javascript}
\label{sub:intercession_in_javascript}

Javascript has no built-in support for intercession. It is not possible to redefine the application of the dot-operator, array indexing, the \texttt{in}-operator and so on.

Spidermonkey, Mozilla's implementation of Javascript, has long included a non-standard way of interceding method calls based on Smalltalk's \texttt{doesNotUnderstand:} method. In Spidermonkey, this method is named \noSuchMethod{}. For example, a proxy that can generically forward all received messages to a target object \texttt{o} is created as follows:

\begin{lstlisting}[language=javascript]
function makeProxy(o) {
  return {
    __noSuchMethod__: function(prop, args) {
      return o[prop].apply(o,args);
    }
  };
}
\end{lstlisting}

% discuss the problems of __noSuchMethod__ (extension of Firefox to enable the creation of proxies in the tradition of Smalltalk-like 'doesNotUnderstand:' hooks)
In what follows, we will refer to methods such as \noSuchMethod{} and \texttt{doesNotUnderstand:} as \emph{traps}. The advantage of such traps is their perceived simplicity. The drawback is that the traps are not \emph{stratified}.

The only way in which a trap is distinguished from a regular method is by their name. Programmers that are unaware of the naming convention could accidentally define a method with the same name, leading to unexpected interactions. A violation of stratification can lead to two subtly different kinds of confusion:

\begin{itemize}
  \item Say an object \texttt{o} purposely overrides the trap. Clients of an object can accidentally invoke the trap method as if it were an application-level method. Since traps are plain methods, nothing prevents these traps from being invoked as if they were plain methods. This confuses meta-level code, since the call ``originated'' from the base-level.
  \item Say an object \texttt{o} accidentally overrides the trap, treating that method name as part of the application. The VM may then incidentally invoke the application method as if it were a trap. This confuses the base-level code, since the call ``originated'' from the meta-level.
\end{itemize}

Granted, for a method named \noSuchMethod{} this hypothetical confusion may seem far-fetched, although in Smalltalk \texttt{doesNotUnderstand:} is a pretty reasonable name for an application to use. But this critique misses the essential point, which is that the intercession API is polluting the name space of the application. This is not a scalable approach. What if we were to introduce additional such traps to intercept not only method invocation, but also property access, assignment, lookup, enumeration, etc.? The number of ``reserved method names'' would quickly grow out of hand. The reason that the lack of stratification has not really posed a significant problem \emph{in practice} is that Spidermonkey and Smalltalk define only one such special method.

So far in our discussion, we have limited the confusion caused by the lack of stratification to the fact that a trap is invoked by the wrong code. However, there are many other ways in which the trap method may conflict with other base-level code. For example, in Javascript a common idiom is to enumerate all properties of an object. Say we want to populate the content of a drop-down list in an HTML form with id \texttt{id} with all of the properties of an object \texttt{obj}:

\begin{lstlisting}[language=javascript]
function populate(id, obj) {
  var select = document.getElementById(id);
  for (var name in obj) {
    // skip inherited properties
    if (!obj.hasOwnProperty(name)) continue;
    var opt = document.createElement('option');
    opt.text = name;
    select.add(opt, null); // append opt
  }
}
\end{lstlisting}

If \texttt{obj} defines \noSuchMethod{} for the sake of intercepting method invocations, this method will show up in the enumeration of \texttt{obj}'s properties, probably leading to unexpected results.

Another drawback of defining the trap as part of the proxy is that it becomes impossible to recursively trap invocations of the trap \emph{itself}. Say \texttt{p} is a proxy. The invocation \lstinline{p.__noSuchMethod__('foo',[1])} itself cannot be intercepted. It is not transparently insert another proxy \texttt{p2} in between the caller and \texttt{p} such that \texttt{p2}'s \noSuchMethod{} trap is invoked as \lstinline{p2.__noSuchMethod__('__noSuchMethod__',['foo',[1]])}. We will show in Section~\ref{sub:doublelifting} that this recursive pattern of proxying proxies themselves has benefits when proxies can trap more than a single operation.

\section{Proxies for Javascript}
\label{sec:proxies_for_javascript}

Our intercession API for Javascript supports intercession only for distinct proxy objects, controlled by a handler object. The methods of the handler object describe the behavior of the language operations when applied to the proxy object. We will call these methods \emph{traps}.

The distinction between a proxy and its handler object enforces stratification of the traps. Traps are no longer methods defined as part of the intercepted object, but are defined on handlers. Handlers can be treated as ``meta-objects'' and their API is effectively the ``metaobject protocol''.

Also, the distinction between proxy objects and regular objects ensures that non-proxy objects (which we expect makes up the vast majority of objects in a system) do not pay the overhead associated with intercession. We support this claim with empirical data in section~\ref{benchmarks}.

A proxy for an object is created as follows:

\begin{lstlisting}[language=javascript]
var proxy = Proxy.create(handler, proto);
\end{lstlisting}

Here, \texttt{handler} is an object that is supposed to implement a particular meta-level API and \texttt{proto} is an optional argument object representing the proxy's prototype.

\begin{table*}[t]
  \begin{center}
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Operation} & \textbf{Triggered by} & \textbf{Reified as}\\
    \hline
    \multicolumn{3}{|l|}{Fundamental traps}\\
    \hline
    Descriptor access & Object.getOwnPropertyDescriptor(proxy,name) & handler.getOwnPropertyDescriptor(name)\\
    \hline
    Descriptor definition & Object.defineProperty(proxy,name,pd) & handler.defineProperty(name,pd)\\
    \hline
    Own key listing & Object.getOwnPropertyNames(proxy) & handler.getOwnPropertyNames()\\
    \hline
    Property deletion & delete proxy.name & handler.delete(name)\\
    \hline
    Key enumeration & for (name in proxy) {...} & handler.enumerate().forEach(function(name) { ... })\\
    \hline
    Object fixing & Object.\{freeze,seal,preventExtensions\}(proxy) & Object.\{freeze,seal,preventExtensions\}(Object.create(proto, handler.fix()))\\
    \hline
    \multicolumn{3}{|l|}{Derived traps}\\
    \hline
    Property lookup & name in proxy & handler.has(name)\\
    \hline
    Own Property lookup & ({}).hasOwnProperty.call(proxy,name) & handler.hasOwn(name)\\
    \hline
    Property access & receiver.name & handler.get(receiver, name)\\
    \hline
    Property assignment & receiver.name = val & handler.set(receiver, name, val)\\
    \hline
    Own key enumeration & Object.keys(proxy) & handler.enumerateOwn()\\
    \hline
    \end{tabular}
  \end{center}
  \caption{Operations reified by the intercession API}
  \label{tab:operations}
\end{table*}

Table~\ref{tab:operations} lists those base-level operations applicable to objects that are reified by our API. The name \texttt{proxy} refers to a proxy instance, \texttt{handler} to that proxy's handler, \texttt{proto} to the prototype specified in \texttt{Proxy.create} and \texttt{receiver} to either a proxy or an object that delegates (directly or indirectly) to a proxy. The distinction between fundamental and derived traps is explained in Section~\ref{sub:fundamental_vs_derived_traps}.

The simplest useful handler is that of a generic forwarding proxy. For such a handler, each trap simply applies the intercepted operation to a target object \texttt{obj}. Most use cases of proxies can be thought of as variations on this default forwarding semantics, usually just augmenting some operations.

\begin{lstlisting}[language=javascript]
function makeForwaringHandler(obj) {
  return {
   has:        function(name) { return name in obj; },
   get:        function(receiver, name) { return obj[name]; },
   set:        function(receiver, name, val) { obj[name] = val; return true; },
   delete:     function(name) { return delete obj[name]; },
   keys:       function() { return Object.keys(obj) },
   ...
  };
};
var proxy = Proxy.create(makeForwaringHandler(obj),
                         Object.getPrototypeOf(obj));
\end{lstlisting}

\subsection{Stratification}

The handler is a regular object. It may delegate to other objects and its delegation chain and is completely independent from that of the proxy it handles. A single handler may handle multiple proxies. The handler can be a proxy itself (we will illustrate a use case of this in Section~\ref{sub:doublelifting}).

Calling \lstinline{aProxy.get}, \lstinline{aProxy.fix} explicitly on a proxy will not trigger the proxy’s corresponding traps. Instead, the call will be reified like any other. That is, \lstinline{aProxy.fix([])} invokes the handler’s \lstinline{invoke(aProxy,'fix',[])} trap. Traps can only be invoked explicitly on a proxy’s handler, not on the proxy itself. This enforces stratification (the meta-level traps should not interfere with base-level method names). Thus, proxies continue to work correctly if an application (by accident or by design) uses the names \texttt{get}, \texttt{set}, \texttt{has}, etc.

This brings us to our first design principle:

\textbf{Stratification:} traps can be stratified by defining them on an object that is distinct from the proxy being intercepted.

\subsection{Temporary Intercession}
\label{sub:immutability}

Recall from section~\cite{sub:introspection_in_js} that Ecmascript 5 introduces the notion of non-extensible, sealed and frozen objects. These objects provide useful guarantees that programmers can rely upon. When designing a proxy mechanism, care should be taken that proxies cannot break these guarantees. For example, if \texttt{o} is an object, then \texttt{Object.freeze(o)} freezes that object. If the programmer knows \texttt{o} is frozen, he can rely on the fact that \texttt{o.foo} will consistently return the same value. If \texttt{o} is a proxy, we do not want a proxy to violate this assumption.

To reconcile non-extensible, sealed and frozen objects with proxies, we introduce an additional trap named \texttt{fix}.

\begin{lstlisting}[language=javascript]
return {
  ...,
  fix: function() {
    if (Object.isFrozen(obj)) {
      return getOwnProperties(obj);
    }
    // As long as obj is not frozen, the proxy won't allow itself to be fixed
    return undefined; // will cause an exception to be thrown
  },
  ...
}
\end{lstlisting}

The \texttt{fix} trap is introduced to enable a proxy to interact with the \texttt{Object.preventExtensions}, \texttt{Object.seal} and \texttt{Object.freeze} primitives available in ECMAScript 5. A non-extensible, sealed or frozen object should somehow restrict the handler’s freedom in terms of what it can return from subsequent calls to \texttt{set}, \texttt{get}, etc. For example, if previous invocations of \texttt{handler.get(p, ``foo'')} returned a non-undefined value (for some \texttt{handler} of a proxy \texttt{p}), then future invocations of \texttt{handler.get(p, ``foo'')} should return the same value when \texttt{p} is frozen.

Proxies enforce these restrictions as follows: every time an external object tries to freeze, seal or make a proxy non-extensible, the \texttt{fix} trap is invoked on the proxy’s handler. At that point, the handler has two options:
\begin{enumerate}
  \item either to refuse the request (by making its \texttt{fix} trap return \texttt{undefined}). The corresponding call to one of the restraining primitives will throw an exception.
  \item or to honor the request, and committing to it by generating a description of an object. The implementation then generates a fresh object based on this description, and from that point on the proxy effectively becomes that object and the handler is bypassed entirely. Any reference to the handler by the implementation is at that point released, making it available for GC. The proxy is now said to be ``fixed''.
\end{enumerate}

What does it mean to generate a description of an object? Ecmascript 5 defines the format of a ``property descriptor map'': an object whose keys map to property descriptors. Such a map effectively describes another object, and it can be instantiated using the built-in function \texttt{Object.create}. For example, the map \lstinline!{x : { value: 5, enumerable: false }}! essentially describes the object \lstinline!{x:5}! except that \texttt{x} will not be enumerated in \texttt{for-in} loops.

The \texttt{fix} trap reuses this existing object-description format to specify the object that the proxy is about to become.

Because of the fixing-protocol, proxies can essentially be in two states. When a proxy is \emph{trapping}, it intercepts all operations and invokes the corresponding handler trap. Once the \texttt{fix} trap returns an object description, the proxy is \emph{fixed}. Once a proxy is fixed, it remains forever fixed.

When an object proxy is fixed, the prototype of the generated object is the \texttt{proto} object passed during proxy construction or \texttt{null} if none was provided. The prototype of a function proxy is always \texttt{Function.prototype}, and this remains unchanged when fixing the function proxy.

\textbf{Temporary Intercession:} if an operation imposes strong consistency requirements on a proxy object (such as becoming immutable), intercession should be disabled for some or all of the operations intercepted by proxies.
%and thus enable the language runtime to enforce the stronger invariants associated with immutability.

Fixing does not necessarily need to be an ``all or nothing'' process. However, in the particular case of Ecmascript, we found this to be the simplest solution.

%\texttt{Object.isExtensible(proxy)} always returns \texttt{true} if a proxy is trapping and \texttt{false} when it is fixed.

%TODO: drop Proxy.isTrapping?
%TODO: could be another important design principle: whether or not to fully virtualize an API
%A method is defined on \texttt{Proxy} to distinguish trapping proxies from regular objects or fixed proxies:
%\texttt{Proxy.isTrapping(anObject)} returns \texttt{true} if and only if \texttt{anObject} is a proxy and is in trapping mode. This is the single, reliable way of testing whether an object is a trapping proxy or not. Note that a proxy cannot influence the outcome of this method. Once a proxy is fixed, it is in all ways simply a normal object, with no built-in way to detect that it had ever been a trapping proxy.

%Design of metalevel API:
%Start from the principle of stratification (cf. Mirrors and Java Proxies, distinction handler vs proxy)
%However, current stratified APIs funnel all meta-level requests through one trap (e.g. in Java: InvocationHandler#invoke)
%
%this distinguishes us from most prior work:
%- either the API is not stratified (e.g. ST's doesNotUnderstand: and the plethora of similar mechanisms in other languages)
%- or it is, but does not support intercession (e.g. Mirrors)
%- or the API is stratified, supports intercession, but has only a single trap (e.g. Java proxies)
%exceptions: AmbientTalk, CLOS's class metaobjects?
%
%When introducing multiple traps, some traps could be 'specializations' or 'generalizations' of other traps.
%Example: 'get' vs. 'invoke' : 'invoke' is a general trap that can be defined in terms of the more specific 'get' trap.
%This can be easily modelled using OOP: traps are methods, some methods are more general 'template methods' defined
%in terms of lower-level methods.
%
%The advantage is that the metaprogrammer need only implement the lower-level traps. The higher-level traps will automatically
%work as expected, working in terms of the lower-level traps.

\subsection{Handlers as Proxies}
\label{sub:doublelifting}
% explain double lifting trick
% handler as a proxy, include figure
% discipline that a proxy only interacts with its handler through method invocation
% implies that at the meta-level, everything is a message send
% -> only need to provide an 'invoke' trap
% hides the complexity of the meta-level API
% apply this to membranes

A common use case for proxy handlers is, for example, to perform an access control check before performing the operation on some wrapped object. Only if the check succeeds is the operation forwarded. Since there are 12 different operations that proxy handlers can intercept, a straightforward implementation would have to duplicate the pattern of access checking and forwarding the operation in each trap. It's difficult to abstract this pattern, because each operation has to be ``forwarded'' in a different way, as exemplified by the forwarding handler in Section~\ref{sec:proxies_for_javascript}. Ideally, if all operations could be uniformly funneled through a single trap, the handler would only have to perform the access check once, in the single trap.

We can achieve such funneling of all operations through a single trap by treating a proxy handler \emph{itself} as a proxy. In meta-programming terms, this corresponds to shifting to the meta-meta-level. To avoid the confusion that invariably follows from such shifting between meta-levels, let us introduce some terminology. The \emph{base-level proxy} is the proxy object that with which other regular application objects will interact. That proxy's handler is the \emph{base-level handler}. If the base-level handler is itself a proxy, it is \emph{also} a \emph{meta-level proxy}. The handler of a meta-level proxy is a \emph{meta-level handler}.

We carefully designed the intercession API such that proxies only interact with their associated handler by invoking their traps. Proxies never assign, enumerate or test for the presence of traps on their handler. Because of this invariant, if the base-level handler is \emph{only} used in its role as the handler for a base-level proxy, the meta-level handler only needs to implement the \texttt{get} trap. Because method invocation is the only operation performed on meta-level proxies, only this single trap is triggered on meta-level handlers.

% TODO: include picture
% a --> b means 'b is the handler of a'
% a ==> b means 'a forwards operations to b'
% base-level proxy --> base-level handler --> meta-level handler ==> forwarding handler ==> target
%                    = meta-level proxy
% p.x                blh.get(p,'x')          mlh.get(blh,'get').apply(blh,[p,'x'])
%                                                                    fh.get(p,'x')      target['x']

Another way to explain why this funneling works is as follows. At the base-level, there is an assortment of operations that are performed on Javascript objects as computation progresses (e.g. property lookup, access, assignment, enumeration, \ldots). At the meta-level (that is: in the intercession API), all of these operations are reified uniformly as method invocations on handlers. Therefore, at the meta-level, the only operation performed on meta-level objects (base-level handlers) is property access, and meta-meta-level objects (meta-level handlers) only need to handle this single operation in their protocol.

We will show an example of this technique of funneling all methods in Section~\ref{sec:membranes}.

Naturally, one can apply this trick of shifting meta-levels at the meta-meta-level recursively. The API allows an arbitrary number of such meta-level shifts. This brings up the question of infinite meta-regress. Such an infinite regress is avoided as long as a proxy handler is eventually implemented as a concrete Javascript object, rather than as yet another proxy.

% Design Principle: handlers can be proxies themselves
% Design Principle: express all meta-level computation (interaction with the handler)
% using a single primitive such that shifting two levels requires intercession of only one operation
To summarize, this section reveals two important design principles of proxy-based intercession APIs:

\textbf{Meta-level shifting:} a proxy-based intercession API supports shifting to a new meta-level by implementing a handler as a proxy.

\textbf{Meta-level funneling:} the interaction between a proxy and its handler determines the API of the meta-meta-level. If the proxy only invokes the handler's traps, then the meta-meta-level API collapses to a single trap through which all meta-level operations are funneled.

\subsection{Selective Interception}
% tradeoff between what to intercess and what to fix upfront

A proxy-based intercession API introduces a tradeoff between what operations can be intercepted by proxy handlers on the one hand, versus what operations have a reliable outcome from the language runtime and the programmer's point of view. We already briefly touched upon this issue in Section~\ref{sub:immutability} when discussing how proxies interact with operations that make non-extensible, sealed or frozen. As we have discussed, the \texttt{fix} trap enables a proxy handler to dynamically decide whether or not to commit to a fixed representation.

% commit to identity upfront (possible because we don't intercess equality)
Some operations may be so critical that we don't want proxies to influence their outcome. One such operation is testing for equality. In Javascript, the expression \texttt{a === b} determines whether \texttt{a} and \texttt{b} refer to identical objects. The \texttt{===} operator comes with an entire list of guarantees that are implicitly taken for granted by programmers. For example, \texttt{===} is commutative, transitive, reflexive and deterministic (it always reports the same answer given the same arguments). Furthermore, testing \texttt{a} and \texttt{b} for equality should not grant \texttt{a} access to \texttt{b} or vice versa. For all these reasons, we decided not to enable proxy handlers to trap \texttt{===}. Proxies cannot influence the outcome of this operation.

As in the case of \texttt{===}, the fact that an operation should be deterministic is a requirement for many operations. To uphold determinism, the operation should not be delegated to a proxy handler. However, just because an operation should have a deterministic result does not mean that it cannot be reliably intercepted. When an operation requires a deterministic, stable result, this result can be provided once to the proxy when it is created. There are two concrete examples of this in our intercession API.

The first example is that proxies must commit to their prototype upfront. Recall from section~\ref{sec:proxies_for_javascript} that the second argument to \texttt{Proxy.create} denotes the proxy's prototype. This has two important effects: the first is that Ecmascript's built-in operation \texttt{Object.getPrototypeOf} remains deterministic, even when applied to a proxy. The second is that proxies cannot influence \texttt{instanceof} when they are used as the left-hand operand: to determine whether \texttt{proxy instanceof Foo} is true, the implementation need only look at the prototype of \texttt{proxy}, which using our API it can do without consulting the proxy.

The second example is that proxies have to decide upfront whether or not they will represent a function. In Javascript, functions are almost plain objects, but they differ in some important aspects. The details are beyond the scope of this paper, but for example the expression \texttt{typeof o} evaluates to \texttt{"object"} if \texttt{o} is ``just'' an object and to \texttt{"function"} if \texttt{o} is a function. Creating a function proxy is quite distinct from creating an object proxy:

\begin{lstlisting}[language=javascript]
var f = Proxy.createFunction(handler, callTrap, constructTrap);
f(); // calls callTrap
new f(); // calls constructTrap
f.x // calls handler.get(f,'x')
\end{lstlisting}

The first argument to \texttt{Proxy.createFunction} is exactly the same kind of handler object used to define object proxies. The additional arguments \texttt{callTrap} and \texttt{constructTrap} are functions that respectively reify Javascript's function call and \texttt{new} operator. By requiring proxies to determine at creation time whether or not they will proxy for an object or a function, the language runtime is able to uphold important invariants that it would have to forfeit if it would have to consult the \texttt{handler}. For example, unlike \texttt{create}, \texttt{createFunction} does not accept a prototype argument. Functions always inherit from \texttt{Function.prototype}, and this API enforces that invariant.

Another aspect to take into account when deciding whether or not a certain operation can be intercepted by a proxy is the fact that it may lead to arbitrary code being run in places where the language runtime or the programmer did not expect this to. For example, without our intercession API, the expression \texttt{name in obj} does not trigger Javascript code. Since \texttt{in} is a primitive operation, the evaluation of this expression occurs entirely within the language runtime, without it ever having to run non-native code. Proxies may change these assumptions.

In our particular case, proxies enable non-native code to run while evaluating the \texttt{in} operator, the \texttt{delete} operator and \texttt{for-in} loops, yet they preserve the integrity of \texttt{===} and \texttt{typeof}. It's hard to make general claims about what operations should generally be interceptable and which should not. It is a design decision that depends on the particulars of the system at hand. The point that we want to make is that it's important to recognize that such a tradeoff exists. This brings us to the following design principle:

\textbf{Selective interception:} determine what properties of an object should be to committed to upfront. If these properties are required to be stable but may be configurable, turn them into parameters of the proxy constructor rather than retrieving them via a handler trap.

\subsection{Fundamental versus derived traps}
\label{sub:fundamental_vs_derived_traps}

The handler protocol of our intercession API provides 12 traps in total, each intercepting a different Javascript operation applied to a proxy. The exact nature of the handler protocol will of course vary greatly from language to language. However, there is one interesting observation about our protocol that we think may apply to other languages as well: some traps can be expressed in terms of the semantics of other traps (i.e. the semantics of the operation which they intercept is subsumed by the semantics of some other operation). We will refer to such traps as \emph{derived} traps, since their implementation may in fact be derived from other, more \emph{fundamental} traps.

\subsubsection{Efficiency: the case for derived traps}

It turns out that our intercession API is comprised of 7 fundamental traps and 5 derived traps. If we can get away with 7 traps, why define 12 of them? The reason is efficiency: implementing a derived trap directly may be more efficient than using its default implementation based on the corresponding fundamental trap. In our particular design, as a rule of thumb, we introduced derived traps only if their implementation could intercept the operation with less allocations than the corresponding implementation based on the fundamental trap.

As a concrete example, consider the expression \texttt{name in obj}. The \texttt{in} operator returns a boolean indicating whether \texttt{obj} defines or inherits a property named \texttt{name}. If \texttt{obj} is a proxy, this operation will trigger the handler's \texttt{has(name)} trap, which should return a boolean. \texttt{has} is a derived trap: its semantics can be directly derived from the fundamental trap \texttt{getPropertyDescriptor} which, given a property name, returns either a property descriptor for a property corresponding to that name if it exists, or returns \texttt{undefined} otherwise. Clearly, \texttt{has} could have just been defined as:

\begin{lstlisting}[language=javascript]
has: function(name) {
  return this.getPropertyDescriptor(name) !== undefined;
}
\end{lstlisting}

While this is a correct implementation of \texttt{has}, the downside is that \texttt{getPropertyDescriptor} needlessly allocates a property descriptor in the case that the named property exists. A custom implementation of \texttt{has} can often avoid this allocation.

While defining the intercession API, we found that there is another force at play that can prevent designers from introducing a derived trap, even if it were more efficient.

\subsubsection{Consistency: the case against derived traps}

One reason \emph{not} to introduce a derived trap, even in the face of improved efficiency, is that introducing the distinction may break language invariants that may surprise the language runtime and programmers.

Once the API provides a proxy handler with both a fundamental and a derived trap, there is no guarantee that a proxy handler will effectively make sure that the derived trap is indeed semantically equivalent to the canonical derived implementation. For example, if a proxy handler is given the option to override both the \texttt{has} and the \texttt{getPropertyDescriptor} traps, it is not enforced that these traps return mutually consistent results. That is, without proxies, the programmer can count on the following invariant:

\begin{lstlisting}[language=javascript]
(name in obj) === (Object.getPropertyDescriptor(name) !== undefined)
\end{lstlisting}

If \texttt{obj} is a proxy, this invariant is no longer guaranteed! \texttt{has} could return true and \texttt{getPropertyDescriptor} could return false. We may characterize a proxy handler with such a behavior as ``ill-defined'' or ``buggy'', but the fact of the matter is that both the language runtime and programmers can no longer count on the invariant being upheld.

The requirement of mutual consistency between operations is an opposing force in the decision of whether or not to introduce a derived trap for a certain operation. Whether the benefits of efficiency outweigh the mutual consistency of operations is, again, based on the particulars of the system and there is no general answer.

One interesting case where mutual consistency outweighed efficiency gain was the decision not to introduce a derived trap to intercept method invocations. In Javascript, a method call expression \texttt{obj.m(1,2,3)} is evaluated by looking up the property \texttt{m} in \texttt{obj}, and then applying the resulting value as a function to the arguments. This semantics can even be expressed approximately in Javascript itself as \texttt{var f = obj.m; f.apply(obj, [1,2,3])}.

In a first design iteration, we defined a separate trap for method invocations: the expression \texttt{proxy.m(1,2,3)} calls \texttt{handler.invoke(obj,'m',[1,2,3])} where \texttt{handler} is \texttt{proxy}'s handler. The expression \texttt{proxy.m} calls \texttt{handler.get(proxy, 'm')}. Clearly, given the invariant sketched in the previous paragraph, \texttt{invoke} is a derived trap corresponding to the more fundamental \texttt{get} trap. Its canonical derived implementation would be:

\begin{lstlisting}[language=javascript]
invoke: function(rcvr, name, args) {
  return this.get(rcvr, name).apply(rcvr, args);
}
\end{lstlisting}

\texttt{invoke} is a useful derived trap because in some cases it can avoid the allocation of a function. Say a proxy wants to virtualize some non-object resource as an object. Say this resource has a property \texttt{foo} that should behave like a method. Part of the proxy handler's traps could be implemented as follows:

\begin{lstlisting}[language=javascript]
get: function(rcvr, name) {
  if (name === 'foo') {
    return function(a,b) {
      // handle proxy.foo(a,b)
    } 
  } else ...
},
invoke: function(rcvr, name, args) {
  if (name === 'foo') {
    // handle proxy.foo(args)
  } else ...
}
\end{lstlisting}

Here, the \texttt{invoke} trap saves the allocation of a function that \texttt{get} has to perform to curry over the arguments of the invocation. Eventually, we dropped the \texttt{invoke} trap because the invariant that it can break is so deeply rooted in the understanding of Javascript's method invocation semantics.

Note that, even if the programmer of a proxy handler has the best intentions to uphold the consistency between fundamental and derived traps (as in the example code above), upholding the consistency introduces a maintenance cost: if either of the two traps is later changed, or any of them gets overridden in a delegating object, the other trap should likewise be changed or overridden.

\textbf{Fundamental versus Derived Traps:} an intercession API faces a tradeoff between defining a minimal API consisting only of fundamental traps versus defining a more complex API that introduces derived traps. Derived traps may be more efficient, but may break invariants that hold between the operations corresponding to the fundamental and the derived trap.

\section{Case: Membranes and Script Compartments}
\label{sec:membranes}
% es-lab's compartments building on membranes

As with the simple membrane of figure 9.3, p 71 of Robust Composition, the following is the simplest expository membrane that satisfies the formal property of unavoidable transitive interposition.
However: missing identity preservation. This can be fixed with Ephemeron tables (ref) but is outside the scope of this paper.

\begin{lstlisting}[language=javascript]
function makeSimpleMembrane(target) {
  var enabled = true;
  
  function wrap(wrapped) {
    if (wrapped !== Object(wrapped)) {
      // this test is only true for primitives
      // primitives provide only irrevocable knowledge,
      // so don't bother wrapping it.
      return wrapped;
    }
 
    var baseHandler = handlerMaker(wrapped);
    var revokeHandler = Proxy.create(Object.freeze({
      invoke: function(rcvr, name, args) {
        if (!enabled) { throw new Error("disabled"); }
        return wrap(baseHandler[name].call(baseHandler,args.map(wrap)));
      }
    }));
          
    return Proxy.create(revokeHandler, 
                        wrap(Object.getPrototype(wrapped)));
  }
    
  return Object.freeze({
    wrapper: wrap(target),
    gate: Object.freeze({
      revoke: function() { enabled = false; }
    });
  });
}
\end{lstlisting}

Application of the membrane abstraction to the isolation of mutually distrustful code:

\begin{lstlisting}[language=javascript]
    var compartment = makeMembrane(eval);
    var eval1 = compartment.wrapper;
    var gate = compartment.gate;
    var badCode = //... obtain potentially malicious code from somewhere ...
    var result = eval1(badCode);
    //... use result ...
    gate.revoke();
    //... contents of compartment gone and collectible ...
\end{lstlisting}

A membrane around an SES \texttt{eval}\footnote{Ref to \texttt{es-lab} project for SES and Securable ES5.} creates a compartment in which one can run potentially malicious code, confident that the resulting potentially malicious objects can interact with the world outside this compartment only as permitted by the objects you provide them. Once the compartment is revoked, not only is all their connectivity severed, it is severed in ways the garbage collector can recognize. Given a good enough collector, these hostile objects cannot even continue to occupy your memory.

\section{Implementation}
Briefly discuss Andreas Gal's Tracemonkey implementation.

\subsection{Micro-benchmarks}
Support the claim that proxies enable intercession at (virtually) no cost to regular objects.

\section{Related Work}

% AOP-based related work
% Eric Tanter's Reflex?

We already discussed in Section~\ref{sub:metaobject_protocols} that many object-oriented systems provide ad hoc support for intercepting messages sent to objects. There is a general category of languages that provide a trap that triggers on missing method definitions only, as exemplified by Smalltalk's \texttt{doesNotUnderstand:}, Spidermonkey's \noSuchMethod{}, Ruby's \texttt{methodMissing}, the E language's \texttt{match} clause, and so on. There are also languages that provide traps that trigger on every method invocation, whether a method is present or not. Examples of this category include Python's \texttt{\_\_getattribute\_\_} and Groovy's \texttt{invokeMethod}. What all of these systems have in common is that the intercession is not stratified. The trap is always defined in a namespace populated with application-level methods.

%In \textbf{Python}, class objects may define methods with special method names (starting with \texttt{__}) that are invoked when certain operations are performed on instances of the class. For example, \texttt{x.y} calls \texttt{type(x).__getattribute__(x, "y")}, where \texttt{type(x)} denotes the class of \texttt{x}. The difference between Python's hooks and proxies is that hooks are not defined on a separate handler object but rather on the class itself. Because hooks are not technically stratified into a separate object, a naming convention is used to avoid name clashes with application-level methods.

Examples of stratified intercession API's include Java proxies, the CLOS metaobject protocol, AmbientTalk mirages and E proxies. We briefly discuss each of these and then summarize which of our design principles they uphold in Table~\ref{tab:related_work}.

%Mirages in AmbientTalk: adds intercession to a Mirror API
The design of Javascript proxies was most directly influenced by \textbf{AmbientTalk} \emph{mirages}~\cite{mirages_dls_07,spe_journal_08}. AmbientTalk mirages enable intercession in a Mirror-based API. Mirrors~\cite{bracha_04_mirrors_oopsla} are a particular kind of reflection API that enforces stratification of base and meta-level. In AmbientTalk, mirages are base-level objects whose meta-object (named a \emph{mirror}) describes their behavior. Mirages correspond to proxies and their mirror corresponds to proxy handlers. AmbientTalk mirrors, like our proxy handlers, implement a metaobject protocol API defining the behavior of all operations applicable to objects.

%CLOS’s metaobject protocol / metaclasses, in particular: the instance structure protocol (intercept slot accesses, i.e. “property access”), the generic function invocation protocol (intercept generic function invocation, i.e. “method calls”)
Metaclasses in the \textbf{CLOS} metaobject protocol~\cite{clos} support a stratified form of intercession. CLOS classes can be declared to have a certain metaclass, that will describe the behavior of that class. This behavior is categorized into different kinds of protocols. For instance, the ``instance structure protocol'' can be used to intercept slot access on the class's instances. The ``generic function invocation protocol'' can be used to intercept generic function invocation.

\textbf{Java}'s \texttt{java.lang.reflect.Proxy} API directly influenced our intercession API for Javascript. In Java, one defines proxies that implement one or more interface types, by calling:

\begin{lstlisting}[language=java]
Foo f = (Foo) Proxy.newProxyInstance(aClassloader,
                                     new Class[] { Foo.class },
                                     invocationHandler);
\end{lstlisting}

Here, the proxy \texttt{f} implements the \texttt{Foo} interface. \texttt{invocationHandler} is an object that implements a single \texttt{invoke} method. All method invocations on \texttt{f} are reified by calling the handler's \texttt{invoke} method.

The main difference between Java proxies and Javascript proxies is that Java proxies only trap method invocation. There are no other meta-level operations to trap. For instance, since interfaces cannot declare fields, proxies do not need to intercept field access. Implementation-wise, another important difference is that Java proxies can be supported by a JVM without the need for a special ``proxy'' object type. A description of the proxy (and all of its methods) can be generated from the given interfaces and subsequently instantiated as a normal object (whose class just happens to be synthesized at runtime).

\textbf{E} has a small intercession API for a special type of object reference known as an \emph{eventual reference}. The API is similar to the Javascript proxy API of this paper. To create custom eventual references, one calls the function \texttt{makeProxy}, passing a proxy handler that implements a small protocol (consisting of 3 traps, to be precise).

\begin{table*}
  \begin{center}
  \begin{tabular}{|p{0.15\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|}
    \hline
    Principle & Javascript proxies & Java proxies & AmbientTalk mirages & CLOS metaobjects & E proxies \\
    \hline
    Intercept on
    & objects % Javascript
    & objects % Java
    & objects % AmbientTalk
    & classes % CLOS
    & references % E
    \\
    \hline
    Stratification 
    & Y (proxy - handler) % Javascript
    & Y (Proxy - InvocationHandler) % Java
    & Y (mirage - mirror) % AmbientTalk
    & Y (object - metaobject) % CLOS
    & Y (proxy - ProxyHandler) % E
    \\
    \hline
    Temporary intercession
    & Y (fix trap) % Javascript
    & N % Java
    & N % AmbientTalk
    & N? % CLOS
    & N % E
    \\
    \hline
    Meta-level shift
    & Y (handler is proxy) % Javascript
    & Y (handler is proxy) % Java
    & Y (mirror is mirage) % AmbientTalk
    & Y? (class metaobject with non-standard class metaobject) % CLOS
    & N? (handler cannot be a proxy) % E
    \\
    \hline
    Funneling
    & Y (get trap) % Javascript
    & Y (trivially) % Java
    & Y (invoke trap) % AmbientTalk
    & N (metalevel itself consists of many operations) % CLOS
    & N? % E
    \\
    \hline
    Selective intercession
    & Y (prototype and type are fixed) % Javascript
    & Y (interfaces are fixed) % Java
    & N % AmbientTalk
    & Y (through specialization of metaobjects) % CLOS e.g. standard-class vs funcallable-standard-class
    & Y (kind of reference is fixed) % E
    \\
    \hline
    Fundamental vs Derived traps
    & Y % Javascript
    & N (just 1 trap) % Java
    & N (all fundamental) % AmbientTalk
    & constraints between methods % CLOS
    & Y (send versus sendOnly) % E
    \\
    \hline
  \end{tabular}
  \end{center}
  \caption{Comparison of stratified intercession APIs}
  \label{tab:related_work}
\end{table*}

\section{Conclusion}

Recapitulate our ``design principles''. Should be generally applicable (apart from Javascript).
\begin{itemize}
  \item Stratification of proxy and handler.
  \item Selective interception: committing to values upfront.
  \item Fundamental versus derived traps: less allocation vs consistency.
  \item Meta-level shifting and funneling traps
  \item Fixing: dealing with immutability.
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{}
\end{document}

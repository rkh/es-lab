Traits: TODO

- try a 'diamond' setup to test whether isSameDesc works.
- define a collections lib with these operators
- more unit tests (compare property maps)

- alternative API: if we would represent traits as functions, we could use the new operator to instantiate traits. We could still provide a to_property_map(trait) -> pdmap function as well.
What about refactoring compose, resolve, override to be defined as methods on traits?

var T = trait({...});
var T3 = T.compose(T2);
var o = new T3({ extend: proto }); // or T3(options) without new

Redesign:
+ rename object to instantiate/build/make
+ redefine object as instantiate + trait

Discussion with Alex:
- override: variable-arity function? (since it's associative anyway, precedence from left to right)
+ the need for extends: to hook up object into prototype chain
for one thing: it allows 'live' changes where all objects constructed from a trait inherit form a mutable object
+ alias and exclude folded into a single 'resolve' operator: map strings to falsy values to exclude them
+ the need for open, malleable, flexible objects:

introduce a single flag to control multiple choices: 'open:' or 'incomplete:'

'open: true' is for abstract or malleable objects and implies
  failOnIncomplete: false,
  failOnConflict: false,
  frozen & frozen methods: false,
  bind methods: false

'open: false' (default) is for high-integrity or final objects
  failOnIncomplete: true,
  failOnConflict: true,
  frozen & frozen methods: true,
  bind methods: true
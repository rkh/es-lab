Traits: TODO
- define a collections lib with these operators:
TIndexable, TSequenceable, TEnumerable,
Collections: Array, LinkedList, OrderedCollection (resizable array, vector), Interval, Set, Dictionary (Map)



== Design rationale not pursued ==

- rename 'open' option to 'final'?
final has the advantage that:
- it's already known as a keyword enforcing similar semantics
- it explicitly tells the programmer that this object will not play nice with objects that delegate to it
the downside: if 'final:true' is the default, then usually 'final' will show up in the source when one means to write: 'final:false', and cognitively it's bad to introduce 'final' only when you create non-final objects...
so: final:false as default could work, but then the 'unsafe' alternative is the default...


- Trait.object({...}) -> would make more sense for users just to write object({...}). Bring 'object' into importer's scope by default? Maybe not... keep it clean... importer can always write var object = Trait.object;


- alternative API: represent traits as function objects instead of as property maps (currently not pursued, disadvantages outweigh advantages)
if we would represent traits as functions, we could use the new operator or function calls to instantiate traits.
We could still provide a to_property_map(trait) -> pdmap function as well.

We could also refactor compose, resolve, override to be defined as methods on the trait function objects:

var T = trait({...});
var T3 = T.compose(T2);
var o = new T3({ extend: proto }); // or T3(options) without new

Pro:
- methods do not pollute an importer's namespace (only need to make available a 'trait' constructor, all other methods are defined on traits)
- we could use a method named 'new' to write trait.new(options) rather than 'build(trait,options)'.
- we can write 'new trait(options)', such that trait instantiation is more close to regular object instantiation in JS.

Con:
- methods make the composition operators look asymmetric as they seem to 'prioritize' the first argument. Might be OK if we rename them and remove variable arity: t1.composeWith(t2), t1.overrideWith(t2), t1.resolve({...}), t1.new(options), t1.eqv(t2)
- traits are no longer property descriptor maps. We need conversion functions to convert between traits and pdmaps:
asTrait(pdMap) -> trait
trait.toPropertyDescriptorMap() -> pdMap
- exposing traits as constructors may only cause additional confusion. Also, stateful traits may cause confusion in combination with 'new', e.g. 'new makePointTrait(x,y)' is wrong! Should be: 'new (makePointTrait(x,y))(options)' or simply '(makePointTrait(x,y))(options)'
- we lose the analogy between Trait.create(proto, pdmap) and Object.create(proto, pdmap)
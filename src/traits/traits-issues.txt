Traits: TODO
- define a collections lib with these operators
TIndexable? (search other languages for more examples)
Collections:
Sequence
  Array [ Indexable sequence? ]
Map
  Hash & TreeMap?

- Trait.new({...}) on ES5 is potentially confusing: does this create a trait or an instance of the trait?
Better: use Trait as a constructor: Trait({...}) generates a new trait, Trait.create generates a new instance of a trait. So Trait({...}) is equivalent to the old 'Trait.trait({...})'.

- Trait.object({...}) -> would make more sense for users just to write object({...}). Bring 'object' into importer's scope by default? Maybe not... keep it clean... importer can always write var object = Trait.object;

- alternative API: represent traits as function objects instead of as property maps (currently not pursued, disadvantages outweigh advantages)
if we would represent traits as functions, we could use the new operator or function calls to instantiate traits.
We could still provide a to_property_map(trait) -> pdmap function as well.

We could also refactor compose, resolve, override to be defined as methods on the trait function objects:

var T = trait({...});
var T3 = T.compose(T2);
var o = new T3({ extend: proto }); // or T3(options) without new

Pro:
- methods do not pollute an importer's namespace (only need to make available a 'trait' constructor, all other methods are defined on traits)
- we could use a method named 'new' to write trait.new(options) rather than 'build(trait,options)'.
- we can write 'new trait(options)', such that trait instantiation is more close to regular object instantiation in JS.

Con:
- methods make the composition operators look asymmetric as they seem to 'prioritize' the first argument. Might be OK if we rename them and remove variable arity: t1.composeWith(t2), t1.overrideWith(t2), t1.resolve({...}), t1.new(options), t1.eqv(t2)
- traits are no longer property descriptor maps. We need conversion functions to convert between traits and pdmaps:
asTrait(pdMap) -> trait
trait.toPropertyDescriptorMap() -> pdMap
- exposing traits as constructors may only cause additional confusion. Also, stateful traits may cause confusion in combination with 'new', e.g. 'new makePointTrait(x,y)' is wrong! Should be: 'new (makePointTrait(x,y))(options)' or simply '(makePointTrait(x,y))(options)'
- we lose the analogy between Trait.create(proto, pdmap) and Object.create(proto, pdmap)
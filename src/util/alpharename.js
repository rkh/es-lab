
/**
 * An alpha conversion for ecmascript as described in the
 * <a href=http://wiki.ecmascript.org/doku.php?id=strawman:alpha-rename>wiki</a>
 *
 * @param rootAst as generated by ES5Parser.
 * @param namer a function that returns a unique ecmascript identifier each
 *   time it is called and that does not conflict with names used in exclusions.
 * @provides alphaRename
 * @requires EMPTY_SET set_union set_singleton let_scoped_decls var_scoped_decls
 *   renderEcmascript
 * @author mikesamuel@gmail.com
 */
function alphaRename(rootAst, namer) {

/**
 * Creates a map mapping each name in identifierSet to a distinct name generated
 * by the namer passed to the α-rename function.
 * @param identifierSet represented as a sorted array per sets.js.
 */
function names(identifierSet) {
  var out = {};
  for (var i = 0, n = identifierSet.length; i < n; ++i) {
    var id = identifierSet[i];
    if (!id) { continue; }
    out[id] = namer();  // invoke namer to generate a unique name
  }
  return out;
}

/**
 * Maps all the names in identifierSet to the same name generated by namer.
 */
function sameNames(identifierSet) {
  var out = {};
  if (identifierSet.length) {
    var name = void 0;
    for (var i = 0, n = identifierSet.length; i < n; ++i) {
      var id = identifierSet[i];
      if (!id) { continue; }
      if (!name) { name = namer(); }  // invoke namer to generate a unique name
      out[id] = name;
    }
  }
  return out;
}

/**
 * Produce a map containing the union of the set of keys in the input maps,
 * and the value for key k from the rightmost map containing key k.
 */
function merge(var_args) {
  var out = {};
  for (var i = 0, n = arguments.length; i < n; ++i) {
    mixin(arguments[i], out);
  }
  return out;
}

function ownProp(o, k) {
  return Object.prototype.hasOwnProperty.call(o, k);
}

/** Copies the own properties of m into out.  Snapshots getters. */
function mixin(m, out) {
  for (var k in m) {
    if (ownProp(m, k)) { out[k] = m[k]; }
  }
}

// Implements http://wiki.ecmascript.org/doku.php?id=strawman:alpha-rename#α-map
function alphaMap(inherited, ast) {
  var type = ast[0];
  switch (type) {
    case 'BlockStmt': case 'ForInStmt': case 'ForStmt':
      return merge(inherited, names(let_scoped_decls(ast)));
    case 'Program':
      return merge(
          inherited, names(set_union(var_scoped_decls(ast),
                                     let_scoped_decls(ast))));
    case 'FunctionDecl':
    case 'FunctionExpr':
      var decls = EMPTY_SET;
      var fnName = ast[2][1] ? ast[2][1].name : null;
      if (fnName) {
        // Use same function name in body and in inner scope for
        // declarations.
        if (type !== 'FunctionDecl' || !ownProp(inherited, fnName)) {
          decls = set_singleton(fnName);
        }
      }
      var params = ast[3];
      for (var i = 2, n = params.length; i < n; ++i) {
        decls = set_union(decls, set_singleton(params[i][1].name));
      }
      for (var i = 4, n = ast.length; i < n; ++i) {
        decls = set_union(decls, set_union(let_scoped_decls(ast[i]),
                                           var_scoped_decls(ast[i])));
      }
      return merge(inherited, {arguments:'arguments'}, names(decls));
    case 'LabelledStmt':
      var label = ast[1].label;
      var labelMap = {};
      labelMap['label ' + label] = namer();
      return merge(inherited, labelMap);
    case 'CatchClause':
      var exMap = {};
      var exName = ast[2][1].name;
      exMap[exName] = namer();
      return merge(inherited, exMap);
    case 'WithStmt': throw new Error('Cannot alpha rename with statements');
    default: return inherited;
  }
}

/** Preserve as many ast properties as we can while defensively copying. */
function copyProps(astProps) {
  var out = {};
  for (var k in astProps) {
    if (!ownProp(astProps, k)) { continue; }
    var v = astProps[k];
    if (typeof v !== 'object' && typeof v !== 'function') { out[k] = v; }
  }
  return out;
}

function substIdent(propName, identPrefix, astProps, alphaMap) {
  if (ownProp(astProps, propName)) {
    var key = identPrefix + astProps[propName];
    if (ownProp(alphaMap, key)) {
      var id = alphaMap[key];
      if ('string' !== typeof id) { throw new Error(id + 'is not a string'); }
      astProps[propName] = id;
    }
  }
}

/**
 * Recusively renames identifiers in an AST.
 * @param parentAst the parent of the current node.  Used for error checking.
 * @param parentAlphaMap the inherited alpha map used to compute the alpha map
 *    for ast.
 * @param ast the node to rename.  Ast is never modified in place.  A copy is
 *    returned unless ast is in the read or write cap lists.
 * @param letScopedNames the set of names of let-scoped variables introduced
 *    in the same var-level scope.
 * @return an AST node.
 */
function renameOne(parentAst, parentAlphaMap, ast, letScopedNames) {
  var astAlphaMap = alphaMap(parentAlphaMap, ast);
  var astProps = ast.length > 1 ? copyProps(ast[1]) : void 0;
  var n = ast.length;
  switch (ast[0]) {
    case 'FunctionDecl': case 'FunctionExpr': letScopedNames = EMPTY_SET; break;
    case 'IdExpr':
      if (astProps.name === 'eval' && parentAst && parentAst[0] === 'CallExpr'
          && ast === parentAst[2]) {  // TODO: remove this once bug 9 fixed
        throw new Error('alpha renaming breaks eval operator');
      } else {
        substIdent('name', '', astProps, astAlphaMap);
        return ['IdExpr', astProps];
      }
    case 'EvalExpr': throw new Error('alpha renaming breaks eval operator');
    case 'IdPatt':
      substIdent('name', '', astProps, astAlphaMap);
      return ['IdPatt', astProps];
    case 'LabelledStmt': case 'BreakStmt': case 'ContinueStmt':
      substIdent('label', 'label ', astProps, astAlphaMap);
      break;
    case 'InitPatt':
      // Fail fast on split initializations such as (var e) in:
      //   try { ... } catch (e) { var e = 1; } return e;
      // In this case, we can't rename the "e" in "var e" to any
      // single name, because the "var" declaration needs to get
      // the name in the scope outside the "catch", and the
      // initializer needs to assign to the exception variable.
      // This problem may arise with other let/var conflicts as in:
      // { let x; ... { var x = 3; ... } }
      if (parentAst && parentAst[0] === 'VarDecl'
          && letScopedNames.indexOf(ast[2][1].name) >= 0) {
        throw new Error('Split initialization of "' + ast[2][1].name + '"');
      }
      break;
    case 'CatchClause':
      letScopedNames = set_union(letScopedNames, set_singleton(ast[2][1].name));
      return [
          ast[0], astProps,
          renameOne(ast, astAlphaMap, ast[2], letScopedNames),
          renameOne(ast, astAlphaMap, ast[3], letScopedNames)];
  }
  var renamedCopy = [ast[0]];
  if (astProps) {
    renamedCopy[1] = astProps;
    letScopedNames = set_union(letScopedNames, let_scoped_decls(ast));
    for (var i = 2; i < n; ++i) {
      renamedCopy[i] = renameOne(ast, astAlphaMap, ast[i], letScopedNames);
    }
  }
  return renamedCopy;
}

return renameOne(null, {}, rootAst, EMPTY_SET);
}
